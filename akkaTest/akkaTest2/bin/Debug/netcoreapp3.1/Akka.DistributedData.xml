<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka.DistributedData</name>
    </assembly>
    <members>
        <member name="T:Akka.DistributedData.DistributedData">
            <summary>
            Akka extension for convenient configuration and use of the
            <see cref="T:Akka.DistributedData.Replicator"/>. Configuration settings are defined in the
            `akka.cluster.ddata` section, see `reference.conf`.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.DistributedData.IsTerminated">
            <summary>
            Returns true if this member is not tagged with the role configured for the replicas.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.DistributedData.Replicator">
            <summary>
            Actor reference of the <see cref="T:Akka.DistributedData.Replicator"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.DistributedData.IsDurable">
            <summary>
            Checks if a durable store for this extension is configured and in use.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.Get(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.DefaultConfig">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.GetKeysAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously returns list of locally known keys.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.GetAsync``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IReadConsistency,System.Threading.CancellationToken)">
            <summary>
            Asynchronously tries to get a replicated value of type <typeparamref name="T"/> stored 
            under a given <paramref name="key"/>, while trying to achieve provided read 
            <paramref name="consistency"/>. If no value was found under provided key, a null value will be returned.
            
            If no <paramref name="consistency"/> will be provided, a <see cref="T:Akka.DistributedData.ReadLocal"/> will be used.
            </summary>
            <exception cref="T:Akka.DistributedData.DataDeletedException">Thrown if value under provided <paramref name="key"/> was permamently deleted. That key can't be used anymore.</exception>
            <exception cref="T:System.TimeoutException">Thrown if get request consistency was not achieved within possible time limit attached to a provided read <paramref name="consistency"/>.</exception>
            <typeparam name="T">Replicated data type to get.</typeparam>
            <param name="key">Key under which a replicated data is stored.</param>
            <param name="consistency">A read consistency requested for this write.</param>
            <param name="cancellation">Cancellation token used to cancel request prematurelly if needed.</param>
            <returns>A task which may return a replicated data value or throw an exception.</returns>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.UpdateAsync``1(Akka.DistributedData.IKey{``0},``0,Akka.DistributedData.IWriteConsistency,System.Threading.CancellationToken)">
            <summary>
            Asynchronously tries to update a replicated value stored under provided <paramref name="key"/> 
            with a <paramref name="replica"/> value within write <paramref name="consistency"/> boundaries. 
            In case of possible conflict a <see cref="M:Akka.DistributedData.IReplicatedData`1.Merge(`0)"/> operation will be performed.
             
            If no <paramref name="consistency"/> will be provided, a <see cref="T:Akka.DistributedData.WriteLocal"/> will be used.
            Keep in mind that failure doesn't mean that write has failed, only that consistency limits were 
            not fulfilled. The value will be probably further updated as propagated using gossip protocol.
            </summary>
            <exception cref="T:Akka.DistributedData.DataDeletedException">Thrown if value under provided <paramref name="key"/> was permamently deleted. That key can't be used anymore.</exception>
            <exception cref="T:System.TimeoutException">Thrown if update request consistency was not achieved within possible time limit attached to a provided read <paramref name="consistency"/>.</exception>
            <typeparam name="T">Replicated data type to update.</typeparam>
            <param name="key">Key under which a replicated data is stored.</param>
            <param name="replica">Value used to perform an update.</param>
            <param name="consistency">A write consistency requested for this write.</param>
            <param name="cancellation">Cancellation token used to cancel request prematurelly if needed.</param>
            <returns>A task which may complete successfully if update was confirmed within provided consistency or throw an exception.</returns>
        </member>
        <member name="M:Akka.DistributedData.DistributedData.DeleteAsync``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IWriteConsistency,System.Threading.CancellationToken)">
            <summary>
            Asynchronously tries to delete a replicated value stored under provided <paramref name="key"/> within 
            specified <paramref name="consistency"/> boundaries. Once deleted, provided key can no longer be used.
            As deletion must be remembered, deleted keys will occupy a small portion of memory, producing a garbadge.
            
            If no <paramref name="consistency"/> will be provided, a <see cref="T:Akka.DistributedData.WriteLocal"/> will be used.
            Keep in mind that failure doesn't mean that delete has failed, only that consistency limits were 
            not fulfilled. The deletion will be propagated using gossip protocol.
            </summary>
            <exception cref="T:System.TimeoutException">Thrown if update request consistency was not achieved within possible time limit attached to a provided read <paramref name="consistency"/>.</exception>
            <typeparam name="T">Replicated data type to update.</typeparam>
            <param name="key">Key under which a replicated data is stored.</param>
            <param name="consistency">A consistency level requested for this deletion.</param>
            <param name="cancellation">Cancellation token used to cancel request prematurelly if needed.</param>
            <returns></returns>
        </member>
        <member name="T:Akka.DistributedData.DistributedDataProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.DistributedDataProvider.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.DistributedDataExtensions.DistributedData(Akka.Actor.ActorSystem)">
            <summary>
            Returns th <see cref="M:Akka.DistributedData.DistributedDataExtensions.DistributedData(Akka.Actor.ActorSystem)"/> extension configured for provided 
            <paramref name="system"/>. Configuration is supplied automatically from HOCON 
            config under the path: `akka.cluster.distributed-data`
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Dsl">
            <summary>
            A helper class used to simplify creation of messages send through 
            the <see cref="T:Akka.DistributedData.Replicator"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Dsl.ReadLocal">
            <summary>
            Gets a <see cref="T:Akka.DistributedData.IReadConsistency"/> setup, which will acknowledge success of 
            a <see cref="M:Akka.DistributedData.Dsl.Get``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IReadConsistency,System.Object)"/> operation immediately as soon, as result will be 
            confirmed by the local replica only.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Dsl.WriteLocal">
            <summary>
            Gets a <see cref="T:Akka.DistributedData.IWriteConsistency"/> setup, which will acknowledge success of an
            <see cref="M:Akka.DistributedData.Dsl.Update``1(Akka.DistributedData.IKey{``0},``0,Akka.DistributedData.IWriteConsistency)">Update</see> or <see cref="M:Akka.DistributedData.Dsl.Delete``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IWriteConsistency,System.Object)"/> operation immediately as soon, as 
            result will be confirmed by the local replica only.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Dsl.GetKeyIds">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will be replied with <see cref="T:Akka.DistributedData.GetKeysIdsResult"/> message having a list of keys 
            for all replicated data structures stored on the current node.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Dsl.GetReplicaCount">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will be replied with <see cref="T:Akka.DistributedData.ReplicaCount"/> message having a number of all 
            replicas known to the current node.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Update``1(Akka.DistributedData.IKey{``0},``0,Akka.DistributedData.IWriteConsistency)">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform an update of a structure stored under provided <paramref name="key"/>.
            If a <paramref name="value"/> will differ from the one already stored, a merge
            operation will be automatically performed in order for those values to converge.
            
            An optional <paramref name="consistency"/> level may be provided to set up certain 
            constraints on retrieved <see cref="T:Akka.DistributedData.IUpdateResponse"/> replied from replicator as 
            a result. If no <paramref name="consistency"/> will be provided, a <see cref="P:Akka.DistributedData.Dsl.WriteLocal"/>
            will be used as a default.
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key under which a replicated <paramref name="value"/> will be stored.</param>
            <param name="value">Replicated data structure to be updated.</param>
            <param name="consistency">Consistency determining how/when response will be emitted.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Update``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IWriteConsistency,System.Func{``0,``0})">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform an update of a structure stored under provided <paramref name="key"/>.
            Update operation is described by <paramref name="modify"/> function, that will take
            a previous value as an input parameter.
            
            An <paramref name="consistency"/> level may be provided to set up certain constraints 
            on retrieved <see cref="T:Akka.DistributedData.IUpdateResponse"/> replied from replicator as a result. 
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key under which a value should be updated.</param>
            <param name="consistency">Consistency determining how/when response will be emitted.</param>
            <param name="modify">An updating function.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Update``1(Akka.DistributedData.IKey{``0},``0,Akka.DistributedData.IWriteConsistency,System.Func{``0,``0})">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform an update of a structure stored under provided <paramref name="key"/>.
            Update operation is described by <paramref name="modify"/> function, that will take
            a previous value as an input parameter. If no value was found under the <paramref name="key"/>,
            an <paramref name="initial"/> value will be used instead.
            
            An <paramref name="consistency"/> level may be provided to set up certain constraints 
            on retrieved <see cref="T:Akka.DistributedData.IUpdateResponse"/> replied from replicator as a result. 
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key under which a value should be updated.</param>
            <param name="initial">Initial value used, when no value has been stored under the provided <paramref name="key"/> so far.</param>
            <param name="consistency">Consistency determining how/when response will be emitted.</param>
            <param name="modify">An updating function.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Update``1(Akka.DistributedData.IKey{``0},``0,Akka.DistributedData.IWriteConsistency,System.Object,System.Func{``0,``0})">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform an update of a structure stored under provided <paramref name="key"/>.
            Update operation is described by <paramref name="modify"/> function, that will take
            a previous value as an input parameter. If no value was found under the <paramref name="key"/>,
            an <paramref name="initial"/> value will be used instead.
            
            An <paramref name="consistency"/> level may be provided to set up certain constraints 
            on retrieved <see cref="T:Akka.DistributedData.IUpdateResponse"/> replied from replicator as a result. 
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key under which a value should be updated.</param>
            <param name="initial">Initial value used, when no value has been stored under the provided <paramref name="key"/> so far.</param>
            <param name="consistency">Consistency determining how/when response will be emitted.</param>
            <param name="request">
            An object added to both generated <see cref="T:Akka.DistributedData.Update"/> request and 
            <see cref="T:Akka.DistributedData.IUpdateResponse"/>. Can be used i.e. as correlation id.
            </param>
            <param name="modify">An updating function.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Get``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IReadConsistency,System.Object)">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform a retrieve of a data structure stored under provided <paramref name="key"/>,
            and reply with <see cref="T:Akka.DistributedData.IGetResponse"/> message.
            
            An optional <paramref name="consistency"/> level may be supplied in order to apply
            certain constraints on the produced response.
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key, for which a value should be retrieved.</param>
            <param name="consistency">A consistency level determining when/how response will be retrieved.</param>
            <param name="request">
            An object added to both generated <see cref="T:Akka.DistributedData.Get"/> request and 
            <see cref="T:Akka.DistributedData.IGetResponse"/>. Can be used i.e. as correlation id.
            </param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Delete``1(Akka.DistributedData.IKey{``0},Akka.DistributedData.IWriteConsistency,System.Object)">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform a delete of a structure stored under provided <paramref name="key"/>,
            and reply with <see cref="T:Akka.DistributedData.IDeleteResponse"/> message.
            
            A delete is irrecoverable - you cannot reinsert a value under the key that has been 
            deleted. If you try, a <see cref="T:Akka.DistributedData.DataDeleted"/> response will be send back.
            
            A deletion doesn't clear all of the memory used by the store. Some portion of it is
            used to keep track of deleted records across the nodes.
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key, for which a value should be retrieved.</param>
            <param name="consistency">A consistency level determining when/how response will be retrieved.</param>
            <param name="request">
            An object added to both generated <see cref="T:Akka.DistributedData.Get"/> request and 
            <see cref="T:Akka.DistributedData.IGetResponse"/>. Can be used i.e. as correlation id.
            </param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Subscribe``1(Akka.DistributedData.IKey{``0},Akka.Actor.IActorRef)">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform a subscription of provided <paramref name="subscriber"/> actor to any
            changes performed on the provided <paramref name="key"/>.
            
            All changes will be send in form of a <see cref="T:Akka.DistributedData.Changed"/> message to the 
            <paramref name="subscriber"/>.
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key used to subscribe an actor to all changes occurring in correlated data structure.</param>
            <param name="subscriber">Actor subscribing to changes under provided <paramref name="key"/>.</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Dsl.Unsubscribe``1(Akka.DistributedData.IKey{``0},Akka.Actor.IActorRef)">
            <summary>
            Constructs a message that, when send to <see cref="P:Akka.DistributedData.DistributedData.Replicator"/>,
            will perform a unsubscription of provided <paramref name="subscriber"/> actor from
            list of provided <paramref name="key"/> subscriptions.
            </summary>
            <typeparam name="T">Replicated data type.</typeparam>
            <param name="key">Key, to which a <paramref name="subscriber"/> has been subscribed previously.</param>
            <param name="subscriber">A subscriber for the <paramref name="key"/>ed value changes.</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Durable.Store">
            <summary>
            Request to store an entry. It optionally contains a <see cref="T:Akka.DistributedData.Durable.StoreReply"/>, which
            should be used to signal success or failure of the operation to the contained
            <see cref="F:Akka.DistributedData.Durable.StoreReply.ReplyTo"/> actor.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Durable.LoadAll">
            <summary>
            Request to load all entries.
            
            It must reply with 0 or more `LoadData` messages
            followed by one `LoadAllCompleted` message to the `sender` (the `Replicator`).
            
            If the `LoadAll` fails it can throw `LoadFailedException` and the `Replicator` supervisor
            will stop itself and the durable store.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.FastMerge`1">
            <summary>
            INTERNAL API
            
            Optimization for add/remove followed by merge and merge should just fast forward to
            the new instance.
            
            It's like a cache between calls of the same thread, you can think of it as a thread local.
            The Replicator actor invokes the user's modify function, which returns a new ReplicatedData instance,
            with the ancestor field set (see for example the add method in ORSet). Then (in same thread) the
            Replication calls merge, which makes use of the ancestor field to perform quick merge
            (see for example merge method in ORSet).
            
            It's not thread safe if the modifying function and merge are called from different threads,
            i.e. if used outside the Replicator infrastructure, but the worst thing that can happen is that
            a full merge is performed instead of the fast forward merge.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.DistributedData.FastMerge`1.Ancestor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.FastMerge`1.AssignAncestor(`0)">
            <summary>
            INTERNAL API: should be called from "updating" methods
            </summary>
            <param name="newData">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.FastMerge`1.IsAncestorOf(`0)">
            <summary>
            INTERNAL API: should be used from merge
            </summary>
            <param name="newData">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.FastMerge`1.ClearAncestor">
            <summary>
            INTERNAL API: should be called from merge 
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.FastMerge`1.Merge(`0)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.FastMerge`1.Merge(Akka.DistributedData.IReplicatedData)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Flag">
            <summary>
            Implements a boolean flag CRDT that is initialized to `false` and
            can be switched to `true`. `true` wins over `false` in merge.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Flag.False">
            <summary>
            Flag with a false value set.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Flag.True">
            <summary>
            Flag with a true value set.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Flag.Enabled">
            <summary>
            Checks if current flag value is set.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Flag.#ctor">
            <summary>
            Creates a new <see cref="T:Akka.DistributedData.Flag"/> instance set to false by default.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Flag.#ctor(System.Boolean)">
            <summary>
            Creates a new <see cref="T:Akka.DistributedData.Flag"/> instance with value set to specified parameter.
            </summary>
            <param name="enabled">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Flag.Equals(Akka.DistributedData.Flag)">
            <summary>
            Checks if two flags are equal to each other.
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Flag.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Flag.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Flag.CompareTo(Akka.DistributedData.Flag)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Flag.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Flag.Akka#DistributedData#IReplicatedData#Merge(Akka.DistributedData.IReplicatedData)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Flag.Merge(Akka.DistributedData.Flag)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Flag.SwitchOn">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Flag.op_Implicit(Akka.DistributedData.Flag)~System.Boolean">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.DistributedData.Flag" /> to <see cref="T:System.Boolean" />.
            </summary>
            <param name="flag">The flag to convert</param>
            <returns>The result of the conversion</returns>
        </member>
        <member name="T:Akka.DistributedData.FlagKey">
            <summary>
            A typed key for <see cref="T:Akka.DistributedData.Flag"/> CRDT. Can be used to perform read/upsert/delete
            operations on correlated data type.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.FlagKey.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Akka.DistributedData.FlagKey"/> class.
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.DistributedData.GCounterKey">
            <summary>
            A typed key for <see cref="T:Akka.DistributedData.GCounter"/> CRDT. Can be used to perform read/upsert/delete
            operations on correlated data type.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GCounterKey.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Akka.DistributedData.GCounterKey"/> class.
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.DistributedData.GCounter">
            <summary>
            Implements a 'Growing Counter' CRDT, also called a 'G-Counter'.
            
            It is described in the paper
            <a href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>.
            
            A G-Counter is a increment-only counter (inspired by vector clocks) in
            which only increment and merge are possible. Incrementing the counter
            adds 1 to the count for the current node. Divergent histories are
            resolved by taking the maximum count for each node (like a vector
            clock merge). The value of the counter is the sum of all node counts.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.GCounter.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.GCounter.Empty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.GCounter.Value">
            <summary>
            Current total value of the counter.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GCounter.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GCounter.#ctor(System.Collections.Immutable.ImmutableDictionary{Akka.Cluster.UniqueAddress,System.UInt64},Akka.DistributedData.GCounter)">
            <summary>
            TBD
            </summary>
            <param name="state">TBD</param>
            <param name="delta">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.GCounter.Increment(Akka.Cluster.Cluster,System.UInt64)">
            <summary>
            Increment the counter with the delta specified. The delta must be zero or positive.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GCounter.Increment(Akka.Cluster.UniqueAddress,System.UInt64)">
            <summary>
            Increment the counter with the delta specified. The delta must be zero or positive.
            </summary>
            <param name="node">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when the specified <paramref name="n"/> is less than zero.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GCounter.Merge(Akka.DistributedData.GCounter)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GCounter.NeedPruningFrom(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GCounter.Prune(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <param name="collapseInto">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GCounter.PruningCleanup(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GCounter.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GCounter.Equals(Akka.DistributedData.GCounter)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GCounter.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GCounter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GCounter.op_Implicit(Akka.DistributedData.GCounter)~System.UInt64">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.DistributedData.GCounter" /> to <see cref="T:System.UInt64" />.
            </summary>
            <param name="counter">The counter to convert</param>
            <returns>The result of the conversion</returns>
        </member>
        <member name="T:Akka.DistributedData.IGSet">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.DistributedData.GSet">
            <summary>
            GSet helper methods.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GSet.Create``1(``0[])">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="elements">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GSet.Create``1(System.Collections.Immutable.IImmutableSet{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="elements">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.GSet`1">
            <summary>
            Implements a 'Add Set' CRDT, also called a 'G-Set'. You can't
            remove elements of a G-Set.
            
            It is described in the paper
            <a href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>.
            
            A G-Set doesn't accumulate any garbage apart from the elements themselves.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.DistributedData.GSet`1.Empty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.GSet`1.Elements">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.#ctor(System.Collections.Immutable.IImmutableSet{`0})">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.#ctor(System.Collections.Immutable.IImmutableSet{`0},Akka.DistributedData.GSet{`0})">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
            <param name="delta"></param>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.Merge(Akka.DistributedData.GSet{`0})">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.Contains(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.DistributedData.GSet`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.GSet`1.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.Add(`0)">
            <summary>
            TBD
            </summary>
            <param name="element">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.Equals(Akka.DistributedData.GSet{`0})">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GSet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IGSetKey">
             <summary>
             INTERNAL API
            
             Marker interface for serialization.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.GSetKey`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.DistributedData.GSetKey`1.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.DistributedData.Internal.GossipTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Internal.GossipTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.GossipTick.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Internal.DeltaPropagationTick">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.DeltaPropagationTick.Instance">
            <summary>
            Singleton instance
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Internal.RemovedNodePruningTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Internal.RemovedNodePruningTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.RemovedNodePruningTick.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Internal.ClockTick">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Internal.ClockTick.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.ClockTick.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Internal.Write">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Write.Key">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Write.Envelope">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Write.FromNode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.Write.#ctor(System.String,Akka.DistributedData.Internal.DataEnvelope,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="key">TBD</param>
            <param name="envelope">TBD</param>
            <param name="fromNode">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Internal.Write.Equals(Akka.DistributedData.Internal.Write)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Write.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Write.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Write.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.WriteAck">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Internal.WriteAck.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteAck.Equals(Akka.DistributedData.Internal.WriteAck)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteAck.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteAck.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteAck.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.WriteNack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Internal.WriteNack.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteNack.Equals(Akka.DistributedData.Internal.WriteNack)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteNack.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteNack.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.WriteNack.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Internal.Read">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Read.Key">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Read.FromNode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.Read.#ctor(System.String,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="key">TBD</param>
            <param name="fromNode">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Internal.Read.Equals(Akka.DistributedData.Internal.Read)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Read.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Read.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Read.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.ReadResult">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.ReadResult.Envelope">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadResult.#ctor(Akka.DistributedData.Internal.DataEnvelope)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadResult.Equals(Akka.DistributedData.Internal.ReadResult)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadResult.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadResult.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.ReadRepair">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.ReadRepair.Key">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.ReadRepair.Envelope">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadRepair.#ctor(System.String,Akka.DistributedData.Internal.DataEnvelope)">
            <summary>
            TBD
            </summary>
            <param name="key">TBD</param>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadRepair.Equals(Akka.DistributedData.Internal.ReadRepair)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadRepair.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadRepair.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadRepair.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.ReadRepairAck">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Internal.ReadRepairAck.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.ReadRepairAck.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.DataEnvelope">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.DataEnvelope.DeletedEnvelope">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.DataEnvelope.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.DataEnvelope.Pruning">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.#ctor(Akka.DistributedData.IReplicatedData,System.Collections.Immutable.ImmutableDictionary{Akka.Cluster.UniqueAddress,Akka.DistributedData.IPruningState},Akka.DistributedData.VersionVector)">
            <summary>
            The <see cref="T:Akka.DistributedData.Internal.DataEnvelope"/> wraps a data entry and carries state of the pruning process for the entry.
            </summary>
            <param name="data">TBD</param>
            <param name="pruning">TBD</param>
            <param name="deltaVersions"></param>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.CleanedDeltaVersions(Akka.Cluster.UniqueAddress)">
            <summary>
            We only use the deltaVersions to track versions per node, not for ordering comparisons,
            so we can just remove the entry for the removed node.
            </summary>
            <param name="from"></param>
            <returns></returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.NeedPruningFrom(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.InitRemovedNodePruning(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removed">TBD</param>
            <param name="owner">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.Prune(Akka.Cluster.UniqueAddress,Akka.DistributedData.PruningPerformed)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="pruningPerformed"></param>
            <exception cref="T:System.ArgumentException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.Merge(Akka.DistributedData.Internal.DataEnvelope)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.Merge(Akka.DistributedData.IReplicatedData)">
            <summary>
            TBD
            </summary>
            <param name="otherData">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.AddSeen(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.Equals(Akka.DistributedData.Internal.DataEnvelope)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.Internal.DataEnvelope.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.Internal.DeletedData">
             <summary>
             INTERNAL API
            
             Placeholder used to represent deleted data that has not yet been pruned or is permanently tombstoned.
             </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.DeletedData.Merge(Akka.DistributedData.Internal.DeletedData)">
            <inheritdoc cref="T:Akka.DistributedData.IReplicatedData`1"/>
        </member>
        <member name="M:Akka.DistributedData.Internal.DeletedData.Merge(Akka.DistributedData.IReplicatedData)">
            <inheritdoc cref="T:Akka.DistributedData.IReplicatedData`1"/>
        </member>
        <member name="M:Akka.DistributedData.Internal.DeletedData.Equals(Akka.DistributedData.Internal.DeletedData)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.DeletedData.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.DeletedData.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.DeletedData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.Status">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Status.Digests">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Status.Chunk">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Status.TotalChunks">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Status.ToSystemUid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Status.FromSystemUid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.Status.#ctor(System.Collections.Immutable.IImmutableDictionary{System.String,Google.Protobuf.ByteString},System.Int32,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            TBD
            </summary>
            <param name="digests">TBD</param>
            <param name="chunk">TBD</param>
            <param name="totalChunks">TBD</param>
            <param name="toSystemUid">TBD</param>
            <param name="fromSystemUid">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Internal.Status.Equals(Akka.DistributedData.Internal.Status)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Status.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Status.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Status.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Internal.Gossip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Gossip.UpdatedData">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Gossip.SendBack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Gossip.ToSystemUid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.DistributedData.Internal.Gossip.FromSystemUid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Internal.Gossip.#ctor(System.Collections.Immutable.IImmutableDictionary{System.String,Akka.DistributedData.Internal.DataEnvelope},System.Boolean,System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            TBD
            </summary>
            <param name="updatedData">TBD</param>
            <param name="sendBack">TBD</param>
            <param name="toSystemUid">TBD</param>
            <param name="fromSystemUid">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.Internal.Gossip.Equals(Akka.DistributedData.Internal.Gossip)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Gossip.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Gossip.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Internal.Gossip.ToString">
            <inheritdoc/>
        </member>
        <member name="F:Akka.DistributedData.Internal.DeltaPropagation.NoDeltaPlaceholder">
            <summary>
            When a DeltaReplicatedData returns `null` from <see cref="T:Akka.DistributedData.Internal.Delta"/> it must still be
            treated as a delta that increase the version counter in <see cref="T:Akka.DistributedData.DeltaPropagationSelector"/>`.
            Otherwise a later delta might be applied before the full state gossip is received
            and thereby violating <see cref="T:Akka.DistributedData.IRequireCausualDeliveryOfDeltas"/>.
            
            This is used as a placeholder for such `null` delta. It's filtered out
            in <see cref="!:DeltaPropagationSelector.CreateDeltaPropagation(ImmutableDictionary&lt;string, Tuple&lt;IReplicatedData, long, long&gt;&gt;)"/>, i.e. never sent to the other replicas.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IReplicatedDataSerialization">
            <summary>
            Marker interface used to indicate that this message will be serialized by <see cref="T:Akka.DistributedData.Serialization.ReplicatedDataSerializer"/>
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IKey">
            <summary>
            Marker interface for all replicated key types in DData.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IKey.Id">
            <summary>
            The identifier for the key.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IKey`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="T:Akka.DistributedData.Key`1">
            <summary>
            Key for the key-value data in <see cref="T:Akka.DistributedData.Replicator"/>. The type of the data value
            is defined in the key. KeySet are compared equal if the `id` strings are equal,
            i.e. use unique identifiers.
            
            Specific classes are provided for the built in data types, e.g. <see cref="T:Akka.DistributedData.ORSetKey`1"/>,
            and you can create your own keys.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="P:Akka.DistributedData.Key`1.Id">
            <summary>
            The identifier for this key.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Key`1.#ctor(System.String)">
            <summary>
            Creates a new key instance.
            </summary>
            <param name="id">The unique identifier for this key.</param>
        </member>
        <member name="M:Akka.DistributedData.Key`1.Equals(Akka.DistributedData.IKey)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Key`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Key`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Key`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Key`1.op_Implicit(Akka.DistributedData.Key{`0})~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.DistributedData.Key`1" /> to <see cref="T:System.String" />.
            </summary>
            <param name="key">The key to convert</param>
            <returns>The result of the conversion</returns>
        </member>
        <member name="T:Akka.DistributedData.ILWWDictionaryKey">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.ILWWDictionaryDeltaOperation">
             <summary>
             INTERNAL API.
            
             For serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.LWWDictionaryKey`2">
            <summary>
            Typed key used to store <see cref="T:Akka.DistributedData.LWWDictionary`2"/> replica 
            inside current <see cref="T:Akka.DistributedData.Replicator"/> key-value store.
            </summary>
            <typeparam name="TKey">Type of a key used by corresponding <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.</typeparam>
            <typeparam name="TValue">Type of a value used by corresponding <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.</typeparam>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionaryKey`2.#ctor(System.String)">
            <summary>
            Creates a new instance of a <see cref="T:Akka.DistributedData.LWWDictionaryKey`2"/> with provided key identifier.
            </summary>
            <param name="id">Identifier used to find corresponding <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.</param>
        </member>
        <member name="T:Akka.DistributedData.ILWWDictionary">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.LWWDictionary">
            <summary>
            A static class with various constructor methods for <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary.Create``2(Akka.Cluster.UniqueAddress,``0,``1,Akka.DistributedData.Clock{``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="node">TBD</param>
            <param name="key">TBD</param>
            <param name="value">TBD</param>
            <param name="clock">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary.Create``2(System.ValueTuple{Akka.Cluster.UniqueAddress,``0,``1}[])">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="elements">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary.Create``2(System.Collections.Generic.IEnumerable{System.ValueTuple{Akka.Cluster.UniqueAddress,``0,``1}},Akka.DistributedData.Clock{``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="elements">TBD</param>
            <param name="clock">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.DistributedData.LWWDictionary`2">
            <summary>
            Specialized <see cref="T:Akka.DistributedData.LWWDictionary`2"/> with <see cref="T:Akka.DistributedData.LWWRegister`1"/> values.
            
            <see cref="T:Akka.DistributedData.LWWRegister`1"/> relies on synchronized clocks and should only be used when the choice of
            value is not important for concurrent updates occurring within the clock skew.
            
            Instead of using timestamps based on DateTime.UtcNow.Ticks time it is possible to
            use a timestamp value based on something else, for example an increasing version number
            from a database record that is used for optimistic concurrency control.
            
            For first-write-wins semantics you can use the <see cref="F:Akka.DistributedData.LWWRegister`1.ReverseClock"/> instead of the
            <see cref="F:Akka.DistributedData.LWWRegister`1.DefaultClock"/>
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
        </member>
        <member name="F:Akka.DistributedData.LWWDictionary`2.Empty">
            <summary>
            An empty instance of the <see cref="T:Akka.DistributedData.LWWDictionary`2"/>
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.#ctor(Akka.DistributedData.ORDictionary{`0,Akka.DistributedData.LWWRegister{`1}})">
            <summary>
            TBD
            </summary>
            <param name="underlying">TBD</param>
        </member>
        <member name="P:Akka.DistributedData.LWWDictionary`2.Entries">
            <summary>
            Returns all entries stored within current <see cref="T:Akka.DistributedData.LWWDictionary`2"/>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.LWWDictionary`2.Keys">
            <summary>
            Returns collection of keys stored within current <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.LWWDictionary`2.Values">
            <summary>
            Returns collection of values stored within current <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.LWWDictionary`2.Item(`0)">
            <summary>
            Returns value stored under provided <paramref name="key"/>.
            </summary>
            <param name="key">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.ContainsKey(`0)">
            <summary>
            Determines current <see cref="T:Akka.DistributedData.LWWDictionary`2"/> contains entry with provided <paramref name="key"/>.
            </summary>
            <param name="key">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.DistributedData.LWWDictionary`2.IsEmpty">
            <summary>
            Determines if current <see cref="T:Akka.DistributedData.LWWDictionary`2"/> is empty.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.LWWDictionary`2.Count">
            <summary>
            Returns number of entries stored within current <see cref="T:Akka.DistributedData.LWWDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.SetItem(Akka.Cluster.Cluster,`0,`1,Akka.DistributedData.Clock{`1})">
            <summary>
            Adds an entry to the map.
            
            You can provide your <paramref name="clock"/> implementation instead of using timestamps based
            on DateTime.UtcNow.Ticks time. The timestamp can for example be an
            increasing version number from a database record that is used for optimistic
            concurrency control.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.SetItem(Akka.Cluster.UniqueAddress,`0,`1,Akka.DistributedData.Clock{`1})">
            <summary>
            Adds an entry to the map.
            
            You can provide your <paramref name="clock"/> implementation instead of using timestamps based
            on DateTime.UtcNow.Ticks time. The timestamp can for example be an
            increasing version number from a database record that is used for optimistic
            concurrency control.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Remove(Akka.Cluster.Cluster,`0)">
            <summary>
            Removes an entry from the map.
            Note that if there is a conflicting update on another node the entry will
            not be removed after merge.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Remove(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            Removes an entry from the map.
            Note that if there is a conflicting update on another node the entry will
            not be removed after merge.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to return a value under provided <paramref name="key"/> is such value exists.
            </summary>
            <param name="key">TBD</param>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Merge(Akka.DistributedData.LWWDictionary{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Merge(Akka.DistributedData.IReplicatedData)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.NeedPruningFrom(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Prune(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <param name="collapseInto">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.PruningCleanup(Akka.Cluster.UniqueAddress)">
            <summary>
            TBD
            </summary>
            <param name="removedNode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Equals(Akka.DistributedData.LWWDictionary{`0,`1})">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.LWWDictionary`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Clock`1">
            <summary>
            Delegate responsible for managing <see cref="T:Akka.DistributedData.LWWRegister`1"/> clock.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="currentTimestamp">The current timestamp value of the <see cref="T:Akka.DistributedData.LWWRegister`1"/>.</param>
            <param name="value">The register value to set and associate with the returned timestamp.</param>
            <returns>Next timestamp</returns>
        </member>
        <member name="T:Akka.DistributedData.ILWWRegisterKey">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.LWWRegisterKey`1">
            <summary>
            Key types for <see cref="T:Akka.DistributedData.LWWRegister`1"/>
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.DistributedData.LWWRegisterKey`1.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.DistributedData.ILWWRegister">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.LWWRegister`1">
            <summary>
            Implements a 'Last Writer Wins Register' CRDT, also called a 'LWW-Register'.
            
            It is described in the paper
            <a href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>.
            
            Merge takes the register with highest timestamp. Note that this
            relies on synchronized clocks. <see cref="T:Akka.DistributedData.LWWRegister`1"/> should only be used when the choice of
            value is not important for concurrent updates occurring within the clock skew.
            
            Merge takes the register updated by the node with lowest address (<see cref="T:Akka.Cluster.UniqueAddress"/> is ordered)
            if the timestamps are exactly the same.
            
            Instead of using timestamps based on `DateTime.UtcNow` time it is possible to
            use a timestamp value based on something else, for example an increasing version number
            from a database record that is used for optimistic concurrency control.
            
            For first-write-wins semantics you can use the <see cref="F:Akka.DistributedData.LWWRegister`1.ReverseClock"/> instead of the
            [[LWWRegister#defaultClock]]
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.DistributedData.LWWRegister`1.DefaultClock">
            <summary>
            Default clock is using max between DateTime.UtcNow.Ticks and current timestamp + 1.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.LWWRegister`1.ReverseClock">
            <summary>
            Reverse clock can be used for first-write-wins semantics. It's counting backwards, 
            using min between -DateTime.UtcNow.Ticks and current timestamp - 1.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.#ctor(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <param name="initial">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.#ctor(Akka.Cluster.UniqueAddress,`0,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <param name="value">TBD</param>
            <param name="timestamp">TBD</param>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.#ctor(Akka.Cluster.UniqueAddress,`0,Akka.DistributedData.Clock{`0})">
            <summary>
            TBD
            </summary>
            <param name="node">TBD</param>
            <param name="initial">TBD</param>
            <param name="clock">TBD</param>
        </member>
        <member name="P:Akka.DistributedData.LWWRegister`1.Timestamp">
            <summary>
            Returns a timestamp used to determine precedence in current register updates.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.LWWRegister`1.Value">
            <summary>
            Returns value of the current register.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.LWWRegister`1.UpdatedBy">
            <summary>
            Returns a unique address of the last cluster node, that updated current register value.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.WithValue(Akka.Cluster.UniqueAddress,`0,Akka.DistributedData.Clock{`0})">
            <summary>
            Change the value of the register.
            
            You can provide your <paramref name="clock"/> implementation instead of using timestamps based
            on DateTime.UtcNow.Ticks time. The timestamp can for example be an
            increasing version number from a database record that is used for optimistic
            concurrency control.
            </summary>
            <param name="node">TBD</param>
            <param name="value">TBD</param>
            <param name="clock">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.Merge(Akka.DistributedData.LWWRegister{`0})">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.Merge(Akka.DistributedData.IReplicatedData)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.Equals(Akka.DistributedData.LWWRegister{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.LWWRegister`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IORDictionaryKey">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IORDictionary">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary.IDeltaOperation">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary.IPutDeltaOp">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary.IRemoveDeltaOp">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary.IRemoveKeyDeltaOp">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary.IUpdateDeltaOp">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary.IDeltaGroupOp">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORDictionary`2">
            <summary>
            Implements a 'Observed Remove Map' CRDT, also called a 'OR-Map'.
            
            It has similar semantics as an <see cref="T:Akka.DistributedData.ORSet`1"/>, but in case of concurrent updates
            the values are merged, and must therefore be <see cref="T:Akka.DistributedData.IReplicatedData"/> types themselves.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.ORDictionary`2.Empty">
            <summary>
            An empty instance of the <see cref="T:Akka.DistributedData.ORDictionary`2"/>
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.#ctor(Akka.DistributedData.ORSet{`0},System.Collections.Immutable.IImmutableDictionary{`0,`1})">
            <summary>
            Creates a new instance of the <see cref="T:Akka.DistributedData.ORDictionary`2"/> class.
            </summary>
            <param name="keySet"></param>
            <param name="valueMap"></param>
        </member>
        <member name="P:Akka.DistributedData.ORDictionary`2.Keys">
            <summary>
            Returns all keys stored within current <see cref="T:Akka.DistributedData.ORDictionary`2"/>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORDictionary`2.Values">
            <summary>
            Returns all values stored within current <see cref="T:Akka.DistributedData.ORDictionary`2"/>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORDictionary`2.Entries">
            <summary>
            Returns all entries stored within current <see cref="T:Akka.DistributedData.ORDictionary`2"/>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORDictionary`2.Item(`0)">
            <summary>
            Returns an element stored under provided <paramref name="key"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to retrieve value under provided <paramref name="key"/>, 
            returning true if value under that key has been found.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.ContainsKey(`0)">
            <summary>
            Checks if provided <paramref name="key"/> can be found inside current <see cref="T:Akka.DistributedData.ORDictionary`2"/>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORDictionary`2.IsEmpty">
            <summary>
            Determines if current <see cref="T:Akka.DistributedData.ORDictionary`2"/> doesn't contain any value.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORDictionary`2.Count">
            <summary>
            Returns number of entries stored within current <see cref="T:Akka.DistributedData.ORDictionary`2"/>
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.SetItem(Akka.Cluster.Cluster,`0,`1)">
            <summary>
            Adds an entry to the map.
            Note that the new <paramref name="value"/> will be merged with existing values
            on other nodes and the outcome depends on what <see cref="T:Akka.DistributedData.IReplicatedData"/>
            type that is used.
            
            Consider using <see cref="M:Akka.DistributedData.ORDictionary`2.AddOrUpdate(Akka.Cluster.Cluster,`0,`1,System.Func{`1,`1})">AddOrUpdate</see> instead of <see cref="M:Akka.DistributedData.ORDictionary`2.SetItem(Akka.Cluster.Cluster,`0,`1)"/> if you want modify
            existing entry.
            
            <see cref="T:System.ArgumentException"/> is thrown if you try to replace an existing <see cref="T:Akka.DistributedData.ORSet`1"/>
            value, because important history can be lost when replacing the `ORSet` and
            undesired effects of merging will occur. Use <see cref="T:Akka.DistributedData.ORMultiValueDictionary`2"/> or <see cref="M:Akka.DistributedData.ORDictionary`2.AddOrUpdate(Akka.Cluster.Cluster,`0,`1,System.Func{`1,`1})">AddOrUpdate</see> instead.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.SetItem(Akka.Cluster.UniqueAddress,`0,`1)">
            <summary>
            Adds an entry to the map.
            Note that the new <paramref name="value"/> will be merged with existing values
            on other nodes and the outcome depends on what <see cref="T:Akka.DistributedData.IReplicatedData"/>
            type that is used.
            
            Consider using <see cref="M:Akka.DistributedData.ORDictionary`2.AddOrUpdate(Akka.Cluster.Cluster,`0,`1,System.Func{`1,`1})">AddOrUpdate</see> instead of <see cref="M:Akka.DistributedData.ORDictionary`2.SetItem(Akka.Cluster.UniqueAddress,`0,`1)"/> if you want modify
            existing entry.
            
            <see cref="T:System.ArgumentException"/> is thrown if you try to replace an existing <see cref="T:Akka.DistributedData.ORSet`1"/>
            value, because important history can be lost when replacing the `ORSet` and
            undesired effects of merging will occur. Use <see cref="T:Akka.DistributedData.ORMultiValueDictionary`2"/> or <see cref="M:Akka.DistributedData.ORDictionary`2.AddOrUpdate(Akka.Cluster.Cluster,`0,`1,System.Func{`1,`1})">AddOrUpdate</see> instead.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.AddOrUpdate(Akka.Cluster.Cluster,`0,`1,System.Func{`1,`1})">
            <summary>
            Replace a value by applying the <paramref name="modify"/> function on the existing value.
            
            If there is no current value for the <paramref name="key"/> the <paramref name="initial"/> value will be
            passed to the <paramref name="modify"/> function.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.AddOrUpdate(Akka.Cluster.UniqueAddress,`0,`1,System.Func{`1,`1})">
            <summary>
            Replace a value by applying the <paramref name="modify"/> function on the existing value.
            
            If there is no current value for the <paramref name="key"/> the <paramref name="initial"/> value will be
            passed to the <paramref name="modify"/> function.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.Remove(Akka.Cluster.Cluster,`0)">
            <summary>
            Removes an entry from the map.
            Note that if there is a conflicting update on another node the entry will
            not be removed after merge.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.Remove(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            Removes an entry from the map.
            Note that if there is a conflicting update on another node the entry will
            not be removed after merge.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.Equals(Akka.DistributedData.ORDictionary{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORDictionary`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IORMultiValueDictionaryKey">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IORMultiValueDictionaryDeltaOperation">
             <summary>
             INTERNAL API.
            
             For serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.IORMultiValueDictionary">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.ORMultiValueDictionary`2">
            <summary>
            An immutable multi-map implementation. This class wraps an
            <see cref="T:Akka.DistributedData.ORDictionary`2"/> with an <see cref="T:Akka.DistributedData.ORSet`1"/> for the map's value.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORMultiValueDictionary`2.Keys">
            <summary>
            Returns all keys stored within current ORMultiDictionary.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ORMultiValueDictionary`2.Values">
            <summary>
            Returns all values stored in all buckets within current ORMultiDictionary.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.SetItems(Akka.Cluster.Cluster,`0,System.Collections.Immutable.IImmutableSet{`1})">
            <summary>
            Sets a <paramref name="bucket"/> of values inside current dictionary under provided <paramref name="key"/>
            in the context of the provided cluster <paramref name="node"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.SetItems(Akka.Cluster.UniqueAddress,`0,System.Collections.Immutable.IImmutableSet{`1})">
            <summary>
            Sets a <paramref name="bucket"/> of values inside current dictionary under provided <paramref name="key"/>
            in the context of the provided cluster <paramref name="node"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.Remove(Akka.Cluster.Cluster,`0)">
            <summary>
            Removes all values inside current dictionary stored under provided <paramref name="key"/>
            in the context of the provided cluster <paramref name="node"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.Remove(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            Removes all values inside current dictionary stored under provided <paramref name="key"/>
            in the context of the provided cluster <paramref name="node"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.AddItem(Akka.Cluster.Cluster,`0,`1)">
            <summary>
            Add an element to a set associated with a key. If there is no existing set then one will be initialised.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.AddItem(Akka.Cluster.UniqueAddress,`0,`1)">
            <summary>
            Add an element to a set associated with a key. If there is no existing set then one will be initialised.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.RemoveItem(Akka.Cluster.Cluster,`0,`1)">
            <summary>
            Remove an element of a set associated with a key. If there are no more elements in the set then the
            entire set will be removed.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.RemoveItem(Akka.Cluster.UniqueAddress,`0,`1)">
            <summary>
            Remove an element of a set associated with a key. If there are no more elements in the set then the
            entire set will be removed.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.ReplaceItem(Akka.Cluster.Cluster,`0,`1,`1)">
            <summary>
            Replace an element of a set associated with a key with a new one if it is different. This is useful when an element is removed
            and another one is added within the same Update. The order of addition and removal is important in order
            to retain history for replicated data.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORMultiValueDictionary`2.ReplaceItem(Akka.Cluster.UniqueAddress,`0,`1,`1)">
            <summary>
            Replace an element of a set associated with a key with a new one if it is different. This is useful when an element is removed
            and another one is added within the same Update. The order of addition and removal is important in order
            to retain history for replicated data.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IORSetKey">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IORSet">
             <summary>
             INTERNAL API
            
             Used for serialization help.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORSet.IDeltaOperation">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORSet.IAddDeltaOperation">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORSet.IRemoveDeltaOperation">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORSet.IDeltaGroupOperation">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.ORSet.IFullStateDeltaOperation">
             <summary>
             INTERNAL API
            
             Used for serialization purposes.
             </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet.SubtractDots(Akka.DistributedData.VersionVector,Akka.DistributedData.VersionVector)">
            <summary>
            INTERNAL API
            Subtract the <paramref name="vvector"/> from the <paramref name="dot"/>.
            What this means is that any (node, version) pair in
            <paramref name="dot"/> that is &lt;= an entry in <paramref name="vvector"/> is removed from <paramref name="dot"/>.
            Example [{a, 3}, {b, 2}, {d, 14}, {g, 22}] -
                    [{a, 4}, {b, 1}, {c, 1}, {d, 14}, {e, 5}, {f, 2}] =
                    [{b, 2}, {g, 22}]
            </summary>
        </member>
        <member name="T:Akka.DistributedData.ORSet`1">
            <summary>
            Implements a 'Observed Remove Set' CRDT, also called a 'OR-Set'.
            Elements can be added and removed any number of times. Concurrent add wins
            over remove.
            
            It is not implemented as in the paper
            <a href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>.
            This is more space efficient and doesn't accumulate garbage for removed elements.
            It is described in the paper
            <a href="https://hal.inria.fr/file/index/docid/738680/filename/RR-8083.pdf">An optimized conflict-free replicated set</a>
            The implementation is inspired by the Riak DT <a href="https://github.com/basho/riak_dt/blob/develop/src/riak_dt_orswot.erl">
            riak_dt_orswot</a>.
            
            The ORSet has a version vector that is incremented when an element is added to
            the set. The `node -&gt; count` pair for that increment is stored against the
            element as its "birth dot". Every time the element is re-added to the set,
            its "birth dot" is updated to that of the `node -&gt; count` version vector entry
            resulting from the add. When an element is removed, we simply drop it, no tombstones.
            
            When an element exists in replica A and not replica B, is it because A added
            it and B has not yet seen that, or that B removed it and A has not yet seen that?
            In this implementation we compare the `dot` of the present element to the version vector
            in the Set it is absent from. If the element dot is not "seen" by the Set version vector,
            that means the other set has yet to see this add, and the item is in the merged
            Set. If the Set version vector dominates the dot, that means the other Set has removed this
            element already, and the item is not in the merged Set.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.ORSet`1.VersionVector">
            <summary>
            Needs to be internal for serialization purposes.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Add(Akka.Cluster.Cluster,`0)">
            <summary>
            Adds an element to the set
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Add(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            Adds an element to the set
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Remove(Akka.Cluster.Cluster,`0)">
            <summary>
            Removes an element from the set.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Remove(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            Removes an element from the set.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Clear(Akka.Cluster.Cluster)">
            <summary>
            Removes all elements from the set, but keeps the history.
            This has the same result as using <see cref="M:Akka.DistributedData.ORSet`1.Remove(Akka.Cluster.Cluster,`0)"/> for each
            element, but it is more efficient.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Clear(Akka.Cluster.UniqueAddress)">
            <summary>
            Removes all elements from the set, but keeps the history.
            This has the same result as using <see cref="M:Akka.DistributedData.ORSet`1.Remove(Akka.Cluster.UniqueAddress,`0)"/> for each
            element, but it is more efficient.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Merge(Akka.DistributedData.ORSet{`0})">
            <summary>
            When element is in this Set but not in that Set:
            Compare the "birth dot" of the present element to the version vector in the Set it is absent from.
            If the element dot is not "seen" by other Set version vector, that means the other set has yet to
            see this add, and the element is to be in the merged Set.
            If the other Set version vector dominates the dot, that means the other Set has removed
            the element already, and the element is not to be in the merged Set.
            
            When element in both this Set and in that Set:
            Some dots may still need to be shed. If this Set has dots that the other Set does not have,
            and the other Set version vector dominates those dots, then we need to drop those dots.
            Keep only common dots, and dots that are not dominated by the other sides version vector
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Equals(Akka.DistributedData.ORSet{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ORSet`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.PNCounter">
            <summary>
            Implements a 'Increment/Decrement Counter' CRDT, also called a 'PN-Counter'.
            
            It is described in the paper
            <a href="http://hal.upmc.fr/file/index/docid/555588/filename/techreport.pdf">A comprehensive study of Convergent and Commutative Replicated Data Types</a>.
            
            PN-Counters allow the counter to be incremented by tracking the
            increments (P) separate from the decrements (N). Both P and N are represented
            as two internal [[GCounter]]s. Merge is handled by merging the internal P and N
            counters. The value of the counter is the value of the P _counter minus
            the value of the N counter.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.Increment(Akka.Cluster.Cluster,System.Int64)">
            <summary>
            Increment the counter with the delta specified.
            If the delta is negative then it will decrement instead of increment.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.Increment(Akka.Cluster.UniqueAddress,System.Int64)">
            <summary>
            Increment the counter with the delta specified.
            If the delta is negative then it will decrement instead of increment.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.Decrement(Akka.Cluster.Cluster,System.Int64)">
            <summary>
            Decrement the counter with the delta specified.
            If the delta is negative then it will increment instead of decrement.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.Decrement(Akka.Cluster.UniqueAddress,System.Int64)">
            <summary>
            Decrement the counter with the delta specified.
            If the delta is negative then it will increment instead of decrement.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.Equals(Akka.DistributedData.PNCounter)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounter.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IPNCounterDictionary">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IPNCounterDictionaryDeltaOperation">
             <summary>
             INTERNAL API.
            
             For serialization purposes.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.PNCounterDictionary`1">
            <summary>
            Map of named counters. Specialized <see cref="T:Akka.DistributedData.ORDictionary`2"/> 
            with <see cref="T:Akka.DistributedData.PNCounter"/> values. 
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.PNCounterDictionary`1.Underlying">
            <summary>
            Needs to be internal for serialization purposes
            </summary>
        </member>
        <member name="P:Akka.DistributedData.PNCounterDictionary`1.Entries">
            <summary>
            Returns all entries stored within current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.PNCounterDictionary`1.Item(`0)">
            <summary>
            Returns a counter value stored within current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/>
            under provided <paramref name="key"/>
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.ContainsKey(`0)">
            <summary>
            Determines if current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/> has a counter
            registered under provided <paramref name="key"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.PNCounterDictionary`1.IsEmpty">
            <summary>
            Determines if current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/> is empty.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.PNCounterDictionary`1.Count">
            <summary>
            Returns number of entries stored within current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.PNCounterDictionary`1.Keys">
            <summary>
            Returns all keys of the current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/>.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.PNCounterDictionary`1.Values">
            <summary>
            Returns all values stored within current <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.TryGetValue(`0,System.Numerics.BigInteger@)">
            <summary>
            Tries to return a value under provided <paramref name="key"/>, if such entry exists.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Increment(Akka.Cluster.Cluster,`0,System.Int64)">
            <summary>
            Increment the counter with the delta specified.
            If the delta is negative then it will decrement instead of increment.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Increment(Akka.Cluster.UniqueAddress,`0,System.Int64)">
            <summary>
            Increment the counter with the delta specified.
            If the delta is negative then it will decrement instead of increment.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Decrement(Akka.Cluster.Cluster,`0,System.Int64)">
            <summary>
            Decrement the counter with the delta specified.
            If the delta is negative then it will increment instead of decrement.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Decrement(Akka.Cluster.UniqueAddress,`0,System.Int64)">
            <summary>
            Decrement the counter with the delta specified.
            If the delta is negative then it will increment instead of decrement.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Remove(Akka.Cluster.Cluster,`0)">
            <summary>
            Removes an entry from the map.
            Note that if there is a conflicting update on another node the entry will
            not be removed after merge.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Remove(Akka.Cluster.UniqueAddress,`0)">
            <summary>
            Removes an entry from the map.
            Note that if there is a conflicting update on another node the entry will
            not be removed after merge.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Equals(Akka.DistributedData.PNCounterDictionary{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.PNCounterDictionary`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IPNCounterDictionaryKey">
            <summary>
            INTERNAL API
            
            Marker interface for serialization
            </summary>
        </member>
        <member name="M:Akka.DistributedData.PruningInitialized.Merge(Akka.DistributedData.IPruningState)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadLocal.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadLocal.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadLocal.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadFrom.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadFrom.Equals(Akka.DistributedData.ReadFrom)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadFrom.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadFrom.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadMajority.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadMajority.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadMajority.Equals(Akka.DistributedData.ReadMajority)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadMajority.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadAll.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadAll.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadAll.Equals(Akka.DistributedData.ReadAll)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReadAll.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IReplicatedData`1">
            <summary>
            Interface for implementing a state based convergent
            replicated data type (CvRDT).
            
            ReplicatedData types must be serializable with an Akka
            Serializer. It is highly recommended to implement a serializer with
            Protobuf or similar. The built in data types are marked with
            <see cref="T:Akka.DistributedData.IReplicatedDataSerialization"/> and serialized with
            <see cref="T:Akka.DistributedData.Serialization.ReplicatedDataSerializer"/>.
            
            Serialization of the data types are used in remote messages and also
            for creating message digests (SHA-1) to detect changes. Therefore it is
            important that the serialization produce the same bytes for the same content.
            For example sets and maps should be sorted deterministically in the serialization.
            
            ReplicatedData types should be immutable, i.e. "modifying" methods should return
            a new instance.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IReplicatedData`1.Merge(`0)">
            <summary>
            Monotonic merge method.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IRemovedNodePruning.ModifiedByNodes">
            <summary>
            The nodes that have changed the state for this data
            and would need pruning when such node is no longer part
            of the cluster.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IRemovedNodePruning.NeedPruningFrom(Akka.Cluster.UniqueAddress)">
            <summary>
            Does it have any state changes from a specific node,
            which has been removed from the cluster.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IRemovedNodePruning`1">
            <summary>
            <see cref="T:Akka.DistributedData.IReplicatedData"/> that has support for pruning of data
            belonging to a specific node may implement this interface.
            When a node is removed from the cluster these methods will be
            used by the <see cref="T:Akka.DistributedData.Replicator"/> to collapse data from the removed node
            into some other node in the cluster.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IRemovedNodePruning`1.Prune(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)">
            <summary>
            When the <paramref name="removedNode"/> node has been removed from the cluster the state
            changes from that node will be pruned by collapsing the data entries
            to another node.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IRemovedNodePruning`1.PruningCleanup(Akka.Cluster.UniqueAddress)">
            <summary>
            Remove data entries from a node that has been removed from the cluster
            and already been pruned.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IDeltaReplicatedData">
            <summary>
            <see cref="T:Akka.DistributedData.IReplicatedData"/> with additional support for delta-CRDT replication.
            delta-CRDT is a way to reduce the need for sending the full state
            for updates. For example adding element 'c' and 'd' to set {'a', 'b'} would
            result in sending the delta {'c', 'd'} and merge that with the state on the
            receiving side, resulting in set {'a', 'b', 'c', 'd'}.
            
            Learn more about this in the paper
            <a href="paper http://arxiv.org/abs/1603.01529">Delta State Replicated Data Types</a>.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IDeltaReplicatedData`2">
            <summary>
            <see cref="T:Akka.DistributedData.IReplicatedData`1"/> with additional support for delta-CRDT replication.
            delta-CRDT is a way to reduce the need for sending the full state
            for updates. For example adding element 'c' and 'd' to set {'a', 'b'} would
            result in sending the delta {'c', 'd'} and merge that with the state on the
            receiving side, resulting in set {'a', 'b', 'c', 'd'}.
            
            Learn more about this in the paper
            <a href="paper http://arxiv.org/abs/1603.01529">Delta State Replicated Data Types</a>.
            </summary>
            <typeparam name="TDelta">
            The type of the delta. To be specified by subclass. It may be the same type as `T` or 
            a different type if needed. For example <see cref="T:Akka.DistributedData.GSet`1"/> uses the same type and 
            <see cref="T:Akka.DistributedData.ORSet`1"/> uses different types.
            </typeparam>
            <typeparam name="T">Replicated data type</typeparam>
        </member>
        <member name="P:Akka.DistributedData.IDeltaReplicatedData`2.Delta">
            <summary>
            The accumulated delta of mutator operations since previous
            <see cref="M:Akka.DistributedData.IDeltaReplicatedData`2.ResetDelta"/>. When the <see cref="T:Akka.DistributedData.Replicator"/> invokes the `modify` function
            of the <see cref="T:Akka.DistributedData.Update"/> message and the user code is invoking one or more mutator
            operations the data is collecting the delta of the operations and makes
            it available for the <see cref="T:Akka.DistributedData.Replicator"/> with the <see cref="P:Akka.DistributedData.IDeltaReplicatedData`2.Delta"/> accessor. The
            `modify` function shall still return the full state in the same way as
            <see cref="T:Akka.DistributedData.IReplicatedData`1"/> without support for deltas.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IDeltaReplicatedData`2.MergeDelta(`1)">
            <summary>
            When delta is merged into the full state this method is used.
            When the type <typeparamref name="TDelta"/> of the delta is of the same type as the full 
            state <typeparamref name="T"/> this method can be implemented by delegating to 
            <see cref="M:Akka.DistributedData.IReplicatedData`1.Merge(`0)"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IDeltaReplicatedData`2.ResetDelta">
            <summary>
            Reset collection of deltas from mutator operations. When the <see cref="T:Akka.DistributedData.Replicator"/>
            invokes the `modify` function of the <see cref="T:Akka.DistributedData.Update"/> message the delta is always
            "reset" and when the user code is invoking one or more mutator operations the
            data is collecting the delta of the operations and makes it available for
            the <see cref="T:Akka.DistributedData.Replicator"/> with the <see cref="P:Akka.DistributedData.IDeltaReplicatedData`2.Delta"/> accessor. When the
            <see cref="T:Akka.DistributedData.Replicator"/> has grabbed the <see cref="P:Akka.DistributedData.IDeltaReplicatedData`2.Delta"/> it will invoke this method 
            to get a clean data instance without the delta.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IReplicatedDelta">
            <summary>
            The delta must implement this type.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IReplicatedDelta.Zero">
            <summary>
            The empty full state. This is used when a delta is received
            and no existing full state exists on the receiving side. Then
            the delta is merged into the <see cref="P:Akka.DistributedData.IReplicatedDelta.Zero"/> to create the initial full state.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IRequireCausualDeliveryOfDeltas">
            <summary>
            Marker that specifies that the deltas must be applied in causal order.
            There is some overhead of managing the causal delivery so it should only
            be used for types that need it.
            
            Note that if the full state type `T` is different from the delta type `D`
            it is the delta `D` that should be marked with this.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.IReplicatedDeltaSize">
            <summary>
            Some complex deltas grow in size for each update and above a configured
            threshold such deltas are discarded and sent as full state instead. This
            interface should be implemented by such deltas to define its size.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IReplicatedDeltaSize.DeltaSize">
            <summary>
            Returns delta size of target delta operation.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Replicator">
            <summary>
            <para>
            A replicated in-memory data store supporting low latency and high availability
            requirements.
            
            The <see cref="T:Akka.DistributedData.Replicator"/> actor takes care of direct replication and gossip based
            dissemination of Conflict Free Replicated Data Types (CRDTs) to replicas in the
            the cluster.
            The data types must be convergent CRDTs and implement <see cref="T:Akka.DistributedData.IReplicatedData`1"/>, i.e.
            they provide a monotonic merge function and the state changes always converge.
            
            You can use your own custom <see cref="T:Akka.DistributedData.IReplicatedData`1"/> or <see cref="T:Akka.DistributedData.IDeltaReplicatedData`2"/> types,
            and several types are provided by this package, such as:
            </para>
            <list type="bullet">
                <item>
                    <term>Counters</term>
                    <description><see cref="T:Akka.DistributedData.GCounter"/>, <see cref="T:Akka.DistributedData.PNCounter"/></description> 
                </item>
                <item>
                    <term>Registers</term>
                    <description><see cref="T:Akka.DistributedData.LWWRegister`1"/>, <see cref="T:Akka.DistributedData.Flag"/></description>
                </item>
                <item>
                    <term>Sets</term>
                    <description><see cref="T:Akka.DistributedData.GSet`1"/>, <see cref="T:Akka.DistributedData.ORSet`1"/></description>
                </item>
                <item>
                    <term>Maps</term> 
                    <description><see cref="T:Akka.DistributedData.ORDictionary`2"/>, <see cref="T:Akka.DistributedData.ORMultiValueDictionary`2"/>, <see cref="T:Akka.DistributedData.LWWDictionary`2"/>, <see cref="T:Akka.DistributedData.PNCounterDictionary`1"/></description>
                </item>
            </list>
            <para>
            For good introduction to the CRDT subject watch the
            <a href="http://www.ustream.tv/recorded/61448875">The Final Causal Frontier</a>
            and <a href="http://vimeo.com/43903960">Eventually Consistent Data Structures</a>
            talk by Sean Cribbs and and the
            <a href="http://research.microsoft.com/apps/video/dl.aspx?id=153540">talk by Mark Shapiro</a>
            and read the excellent paper <a href="http://hal.upmc.fr/docs/00/55/55/88/PDF/techreport.pdf">
            A comprehensive study of Convergent and Commutative Replicated Data Types</a>
            by Mark Shapiro et. al.
            </para>
            <para>
            The <see cref="T:Akka.DistributedData.Replicator"/> actor must be started on each node in the cluster, or group of
            nodes tagged with a specific role. It communicates with other <see cref="T:Akka.DistributedData.Replicator"/> instances
            with the same path (without address) that are running on other nodes . For convenience it
            can be used with the <see cref="T:Akka.DistributedData.DistributedData"/> extension but it can also be started as an ordinary
            actor using the <see cref="M:Akka.DistributedData.Replicator.Props(Akka.DistributedData.ReplicatorSettings)"/>. If it is started as an ordinary actor it is important
            that it is given the same name, started on same path, on all nodes.
            </para>
            <para>
            <a href="paper http://arxiv.org/abs/1603.01529">Delta State Replicated Data Types</a>
            is supported. delta-CRDT is a way to reduce the need for sending the full state
            for updates. For example adding element 'c' and 'd' to set {'a', 'b'} would
            result in sending the delta {'c', 'd'} and merge that with the state on the
            receiving side, resulting in set {'a', 'b', 'c', 'd'}.
            </para>
            <para>
            The protocol for replicating the deltas supports causal consistency if the data type
            is marked with <see cref="T:Akka.DistributedData.IRequireCausualDeliveryOfDeltas"/>. Otherwise it is only eventually
            consistent. Without causal consistency it means that if elements 'c' and 'd' are
            added in two separate <see cref="T:Akka.DistributedData.Update"/> operations these deltas may occasionally be propagated
            to nodes in different order than the causal order of the updates. For this example it
            can result in that set {'a', 'b', 'd'} can be seen before element 'c' is seen. Eventually
            it will be {'a', 'b', 'c', 'd'}.
            </para>
            <para>
            == Update ==
            
            To modify and replicate a <see cref="T:Akka.DistributedData.IReplicatedData`1"/> value you send a <see cref="T:Akka.DistributedData.Update"/> message
            to the local <see cref="T:Akka.DistributedData.Replicator"/>.
            The current data value for the `key` of the <see cref="T:Akka.DistributedData.Update"/> is passed as parameter to the `modify`
            function of the <see cref="T:Akka.DistributedData.Update"/>. The function is supposed to return the new value of the data, which
            will then be replicated according to the given consistency level.
            
            The `modify` function is called by the `Replicator` actor and must therefore be a pure
            function that only uses the data parameter and stable fields from enclosing scope. It must
            for example not access `sender()` reference of an enclosing actor.
            
            <see cref="T:Akka.DistributedData.Update"/> is intended to only be sent from an actor running in same local `ActorSystem` as
            the <see cref="T:Akka.DistributedData.Replicator"/>, because the `modify` function is typically not serializable.
            
            You supply a write consistency level which has the following meaning:
            <list type="bullet">
                <item>
                    <term><see cref="T:Akka.DistributedData.WriteLocal"/></term>
                    <description>
                        The value will immediately only be written to the local replica, and later disseminated with gossip.
                    </description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.WriteTo"/></term>
                    <description>
                        The value will immediately be written to at least <see cref="P:Akka.DistributedData.WriteTo.Count"/> replicas, including the local replica.
                    </description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.WriteMajority"/></term>
                    <description>
                        The value will immediately be written to a majority of replicas, i.e. at least `N/2 + 1` replicas, 
                        where N is the number of nodes in the cluster (or cluster role group).
                    </description>     
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.WriteAll"/></term> 
                    <description>
                        The value will immediately be written to all nodes in the cluster (or all nodes in the cluster role group).
                    </description>
                </item>
            </list>
            
            As reply of the <see cref="T:Akka.DistributedData.Update"/> a <see cref="T:Akka.DistributedData.UpdateSuccess"/> is sent to the sender of the
            <see cref="T:Akka.DistributedData.Update"/> if the value was successfully replicated according to the supplied consistency
            level within the supplied timeout. Otherwise a <see cref="T:Akka.DistributedData.IUpdateFailure"/> subclass is
            sent back. Note that a <see cref="T:Akka.DistributedData.UpdateTimeout"/> reply does not mean that the update completely failed
            or was rolled back. It may still have been replicated to some nodes, and will eventually
            be replicated to all nodes with the gossip protocol.
            
            You will always see your own writes. For example if you send two <see cref="T:Akka.DistributedData.Update"/> messages
            changing the value of the same `key`, the `modify` function of the second message will
            see the change that was performed by the first <see cref="T:Akka.DistributedData.Update"/> message.
            
            In the <see cref="T:Akka.DistributedData.Update"/> message you can pass an optional request context, which the <see cref="T:Akka.DistributedData.Replicator"/>
            does not care about, but is included in the reply messages. This is a convenient
            way to pass contextual information (e.g. original sender) without having to use <see cref="!:Ask"/>
            or local correlation data structures.
            </para>
            <para>
            == Get ==
            
            To retrieve the current value of a data you send <see cref="T:Akka.DistributedData.Get"/> message to the
            <see cref="T:Akka.DistributedData.Replicator"/>. You supply a consistency level which has the following meaning:
            <list type="bullet">
                <item>
                    <term><see cref="T:Akka.DistributedData.ReadLocal"/></term> 
                    <description>The value will only be read from the local replica.</description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.ReadFrom"/></term> 
                    <description>The value will be read and merged from <see cref="P:Akka.DistributedData.ReadFrom.N"/> replicas, including the local replica.</description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.ReadMajority"/></term>
                    <description>
                        The value will be read and merged from a majority of replicas, i.e. at least `N/2 + 1` replicas, where N is the number of nodes in the cluster (or cluster role group).
                    </description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.ReadAll"/></term>
                    <description>The value will be read and merged from all nodes in the cluster (or all nodes in the cluster role group).</description>
                </item>
            </list>
            
            As reply of the <see cref="T:Akka.DistributedData.Get"/> a <see cref="T:Akka.DistributedData.GetSuccess"/> is sent to the sender of the
            <see cref="T:Akka.DistributedData.Get"/> if the value was successfully retrieved according to the supplied consistency
            level within the supplied timeout. Otherwise a <see cref="T:Akka.DistributedData.GetFailure"/> is sent.
            If the key does not exist the reply will be <see cref="T:Akka.DistributedData.NotFound"/>.
            
            You will always read your own writes. For example if you send a <see cref="T:Akka.DistributedData.Update"/> message
            followed by a <see cref="T:Akka.DistributedData.Get"/> of the same `key` the <see cref="T:Akka.DistributedData.Get"/> will retrieve the change that was
            performed by the preceding <see cref="T:Akka.DistributedData.Update"/> message. However, the order of the reply messages are
            not defined, i.e. in the previous example you may receive the <see cref="T:Akka.DistributedData.GetSuccess"/> before
            the <see cref="T:Akka.DistributedData.UpdateSuccess"/>.
            
            In the <see cref="T:Akka.DistributedData.Get"/> message you can pass an optional request context in the same way as for the
            <see cref="T:Akka.DistributedData.Update"/> message, described above. For example the original sender can be passed and replied
            to after receiving and transforming <see cref="T:Akka.DistributedData.GetSuccess"/>.
            </para>
            <para>
            == Subscribe ==
            
            You may also register interest in change notifications by sending <see cref="T:Akka.DistributedData.Subscribe"/>
            message to the <see cref="T:Akka.DistributedData.Replicator"/>. It will send <see cref="T:Akka.DistributedData.Changed"/> messages to the registered
            subscriber when the data for the subscribed key is updated. Subscribers will be notified
            periodically with the configured `notify-subscribers-interval`, and it is also possible to
            send an explicit <see cref="T:Akka.DistributedData.FlushChanges"/> message to the <see cref="T:Akka.DistributedData.Replicator"/> to notify the subscribers
            immediately.
            
            The subscriber is automatically removed if the subscriber is terminated. A subscriber can
            also be deregistered with the <see cref="T:Akka.DistributedData.Unsubscribe"/> message.
            </para>
            <para>
            == Delete ==
            
            A data entry can be deleted by sending a <see cref="T:Akka.DistributedData.Delete"/> message to the local
            local <see cref="T:Akka.DistributedData.Replicator"/>. As reply of the <see cref="T:Akka.DistributedData.Delete"/> a <see cref="T:Akka.DistributedData.DeleteSuccess"/> is sent to
            the sender of the <see cref="T:Akka.DistributedData.Delete"/> if the value was successfully deleted according to the supplied
            consistency level within the supplied timeout. Otherwise a <see cref="T:Akka.DistributedData.ReplicationDeleteFailure"/>
            is sent. Note that <see cref="T:Akka.DistributedData.ReplicationDeleteFailure"/> does not mean that the delete completely failed or
            was rolled back. It may still have been replicated to some nodes, and may eventually be replicated
            to all nodes.
            
            A deleted key cannot be reused again, but it is still recommended to delete unused
            data entries because that reduces the replication overhead when new nodes join the cluster.
            Subsequent <see cref="T:Akka.DistributedData.Delete"/>, <see cref="T:Akka.DistributedData.Update"/> and <see cref="T:Akka.DistributedData.Get"/> requests will be replied with <see cref="T:Akka.DistributedData.DataDeleted"/>.
            Subscribers will receive <see cref="!:Deleted"/>.
            
            In the <see cref="T:Akka.DistributedData.Delete"/> message you can pass an optional request context in the same way as for the
            <see cref="T:Akka.DistributedData.Update"/> message, described above. For example the original sender can be passed and replied
            to after receiving and transforming <see cref="T:Akka.DistributedData.DeleteSuccess"/>.
            </para>
            <para>
            == CRDT Garbage ==
            
            One thing that can be problematic with CRDTs is that some data types accumulate history (garbage).
            For example a <see cref="T:Akka.DistributedData.GCounter"/> keeps track of one counter per node. If a <see cref="T:Akka.DistributedData.GCounter"/> has been updated
            from one node it will associate the identifier of that node forever. That can become a problem
            for long running systems with many cluster nodes being added and removed. To solve this problem
            the <see cref="T:Akka.DistributedData.Replicator"/> performs pruning of data associated with nodes that have been removed from the
            cluster. Data types that need pruning have to implement <see cref="T:Akka.DistributedData.IRemovedNodePruning`1"/>. The pruning consists
            of several steps:
            <list type="">
                <item>When a node is removed from the cluster it is first important that all updates that were
            done by that node are disseminated to all other nodes. The pruning will not start before the
            <see cref="P:Akka.DistributedData.ReplicatorSettings.MaxPruningDissemination"/> duration has elapsed. The time measurement is stopped when any
            replica is unreachable, but it's still recommended to configure this with certain margin.
            It should be in the magnitude of minutes.</item>
            <item>The nodes are ordered by their address and the node ordered first is called leader.
            The leader initiates the pruning by adding a <see cref="T:Akka.DistributedData.PruningInitialized"/> marker in the data envelope.
            This is gossiped to all other nodes and they mark it as seen when they receive it.</item>
            <item>When the leader sees that all other nodes have seen the <see cref="T:Akka.DistributedData.PruningInitialized"/> marker
            the leader performs the pruning and changes the marker to <see cref="T:Akka.DistributedData.PruningPerformed"/> so that nobody
            else will redo the pruning. The data envelope with this pruning state is a CRDT itself.
            The pruning is typically performed by "moving" the part of the data associated with
            the removed node to the leader node. For example, a <see cref="T:Akka.DistributedData.GCounter"/> is a `Map` with the node as key
            and the counts done by that node as value. When pruning the value of the removed node is
            moved to the entry owned by the leader node. See <see cref="M:Akka.DistributedData.IRemovedNodePruning`1.Prune(Akka.Cluster.UniqueAddress,Akka.Cluster.UniqueAddress)"/>.</item>
            <item>Thereafter the data is always cleared from parts associated with the removed node so that
            it does not come back when merging. See <see cref="M:Akka.DistributedData.IRemovedNodePruning`1.PruningCleanup(Akka.Cluster.UniqueAddress)"/></item>
            <item>After another `maxPruningDissemination` duration after pruning the last entry from the
            removed node the <see cref="T:Akka.DistributedData.PruningPerformed"/> markers in the data envelope are collapsed into a
            single tombstone entry, for efficiency. Clients may continue to use old data and therefore
            all data are always cleared from parts associated with tombstoned nodes. </item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._nodes">
            <summary>
            Cluster nodes, doesn't contain selfAddress.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._weaklyUpNodes">
            <summary>
            Cluster weaklyUp nodes, doesn't contain selfAddress
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._leader">
            <summary>
            All nodes sorted with the leader first
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._previousClockTime">
            <summary>
            For pruning timeouts are based on clock that is only increased when all nodes are reachable.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._dataEntries">
            <summary>
            The actual data.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._changed">
            <summary>
            Keys that have changed, Changed event published to subscribers on FlushChanges
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Replicator._statusCount">
            <summary>
            For splitting up gossip in chunks.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GetKeyIds.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetKeyIds.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetKeysIdsResult.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetKeysIdsResult.Equals(Akka.DistributedData.GetKeysIdsResult)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetKeysIdsResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetKeysIdsResult.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Get">
            <summary>
            Send this message to the local <see cref="T:Akka.DistributedData.Replicator"/> to retrieve a data value for the
            given `key`. The `Replicator` will reply with one of the <see cref="T:Akka.DistributedData.IGetResponse"/> messages.
            
            The optional `request` context is included in the reply messages. This is a convenient
            way to pass contextual information (e.g. original sender) without having to use `ask`
            or maintain local correlation data structures.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Get.Equals(Akka.DistributedData.Get)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Get.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Get.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Get.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IGetResponse">
            <summary>
            Common response interface on <see cref="M:Akka.DistributedData.IGetResponse.Get``1(Akka.DistributedData.IKey{``0})"/> request. It can take one of 
            the tree possible values:
            <ul>
            <li><see cref="T:Akka.DistributedData.GetSuccess"/> with the result of the request.</li>
            <li><see cref="T:Akka.DistributedData.NotFound"/> when a value for requested key didn't exist.</li>
            <li><see cref="T:Akka.DistributedData.GetFailure"/> when an exception happened when fulfilling the request.</li>
            </ul>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IGetResponse.Key">
            <summary>
            Initial key send by <see cref="M:Akka.DistributedData.IGetResponse.Get``1(Akka.DistributedData.IKey{``0})"/> request.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IGetResponse.Request">
            <summary>
            Optional object used for request/response correlation.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IGetResponse.IsSuccessful">
            <summary>
            True if value for request was successfully returned.
            False if value was either not found or ended with failure.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IGetResponse.IsFound">
            <summary>
            False if value for request was not found. True otherwise.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IGetResponse.IsFailure">
            <summary>
            True if a failure happened during request fulfillment.
            False if returned successfully or value not found for the key.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IGetResponse.Get``1(Akka.DistributedData.IKey{``0})">
            <summary>
            Tries to return a result of the request, given a replicated collection 
            <paramref name="key"/> used when sending a <see cref="!:Replicator.Get"/> request.
            </summary>
            <typeparam name="T">Replicated data.</typeparam>
            <param name="key">Key send originally with a <see cref="!:Replicator.Get"/> request.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown when no value for provided <paramref name="key"/> was found.</exception>
            <exception cref="T:System.TimeoutException">Thrown when response with given consistency didn't arrive within specified timeout.</exception>
            <returns></returns>
        </member>
        <member name="M:Akka.DistributedData.GetSuccess.#ctor(Akka.DistributedData.IKey,System.Object,Akka.DistributedData.IReplicatedData)">
            <summary>
            Reply from <see cref="M:Akka.DistributedData.GetSuccess.Get``1(Akka.DistributedData.IKey{``0})"/>. The data value is retrieved with <see cref="P:Akka.DistributedData.GetSuccess.Data"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GetSuccess.Equals(Akka.DistributedData.GetSuccess)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetSuccess.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetSuccess.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetSuccess.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.NotFound.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.NotFound.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.NotFound.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.GetFailure">
            <summary>
            The <see cref="M:Akka.DistributedData.GetFailure.Get``1(Akka.DistributedData.IKey{``0})"/> request could not be fulfill according to the given
            <see cref="T:Akka.DistributedData.IReadConsistency"/> level and <see cref="P:Akka.DistributedData.IReadConsistency.Timeout"/> timeout.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.GetFailure.Equals(Akka.DistributedData.GetFailure)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetFailure.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetFailure.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.GetFailure.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Subscribe">
            <summary>
            Register a subscriber that will be notified with a <see cref="T:Akka.DistributedData.Changed"/> message
            when the value of the given <see cref="P:Akka.DistributedData.Subscribe.Key"/> is changed. Current value is also
            sent as a <see cref="T:Akka.DistributedData.Changed"/> message to a new subscriber.
            
            Subscribers will be notified periodically with the configured `notify-subscribers-interval`,
            and it is also possible to send an explicit `FlushChanges` message to
            the <see cref="T:Akka.DistributedData.Replicator"/> to notify the subscribers immediately.
            
            The subscriber will automatically be unregistered if it is terminated.
            
            If the key is deleted the subscriber is notified with a <see cref="T:Akka.DistributedData.DataDeleted"/> message.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Subscribe.Equals(Akka.DistributedData.Subscribe)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Subscribe.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Subscribe.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Subscribe.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Unsubscribe">
            <summary>
            Unregister a subscriber.
            </summary>
            <seealso cref="T:Akka.DistributedData.Subscribe"/>
        </member>
        <member name="M:Akka.DistributedData.Unsubscribe.Equals(Akka.DistributedData.Unsubscribe)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Unsubscribe.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Unsubscribe.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Unsubscribe.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Changed">
            <summary>
            The data value is retrieved with <see cref="P:Akka.DistributedData.Changed.Data"/> using the typed key.
            </summary>
            <seealso cref="T:Akka.DistributedData.Subscribe"/>
        </member>
        <member name="M:Akka.DistributedData.Changed.Equals(Akka.DistributedData.Changed)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Changed.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Changed.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Changed.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Update">
            <summary>
            Send this message to the local <see cref="T:Akka.DistributedData.Replicator"/> to update a data value for the
            given <see cref="P:Akka.DistributedData.Update.Key"/>. The <see cref="T:Akka.DistributedData.Replicator"/> will reply with one of the 
            <see cref="T:Akka.DistributedData.IUpdateResponse"/> messages.
            
            The current data value for the <see cref="P:Akka.DistributedData.Update.Key"/> is passed as parameter to the <see cref="P:Akka.DistributedData.Update.Modify"/> function.
            It is <see langword="null"/> if there is no value for the <see cref="P:Akka.DistributedData.Update.Key"/>, and otherwise <see cref="P:Akka.DistributedData.Update.Request"/>. The function
            is supposed to return the new value of the data, which will then be replicated according to
            the given <see cref="T:Akka.DistributedData.IWriteConsistency"/>.
            
            The <see cref="P:Akka.DistributedData.Update.Modify"/> function is called by the `<see cref="T:Akka.DistributedData.Replicator"/>` actor and must therefore be a pure
            function that only uses the data parameter and stable fields from enclosing scope. It must
            for example not access `sender()` reference of an enclosing actor.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Update.#ctor(Akka.DistributedData.IKey,Akka.DistributedData.IReplicatedData,Akka.DistributedData.IWriteConsistency,System.Func{Akka.DistributedData.IReplicatedData,Akka.DistributedData.IReplicatedData},System.Object)">
            <summary>
            Modify value of local <see cref="T:Akka.DistributedData.Replicator"/> and replicate with given <see cref="T:Akka.DistributedData.IWriteConsistency"/>.
            
            The current value for the <see cref="P:Akka.DistributedData.Update.Key"/> is passed to the <see cref="P:Akka.DistributedData.Update.Modify"/> function.
            If there is no current data value for the <see cref="P:Akka.DistributedData.Update.Key"/> the <paramref name="initial"/> value will be
            passed to the <see cref="P:Akka.DistributedData.Update.Modify"/> function.
            
            The optional <paramref name="request"/> context is included in the reply messages. This is a convenient
            way to pass contextual information (e.g. original sender) without having to use `ask`
            or local correlation data structures.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Update.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IUpdateResponse">
            <summary>
            A response message for the <see cref="T:Akka.DistributedData.Update"/> request. It can be one of the 3 possible types:
            <ul>
            <li><see cref="T:Akka.DistributedData.UpdateSuccess"/> when update has finished successfully with given write consistency withing provided time limit.</li>
            <li><see cref="T:Akka.DistributedData.ModifyFailure"/> if a <see cref="P:Akka.DistributedData.Update.Modify"/> delegate has thrown a failure.</li>
            <li><see cref="T:Akka.DistributedData.UpdateTimeout"/> if a request couldn't complete withing given timeout and write consistency constraints.</li>
            </ul>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IUpdateResponse.Key">
            <summary>
            Key, under with updated data is going to be stored.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IUpdateResponse.Request">
            <summary>
            Optional object that can be used to correlate this response with particular <see cref="T:Akka.DistributedData.Update"/> request.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IUpdateResponse.IsSuccessful">
            <summary>
            Returns true if <see cref="T:Akka.DistributedData.Update"/> request has completed successfully.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.IUpdateResponse.ThrowOnFailure">
            <summary>
            Throws an exception if <see cref="T:Akka.DistributedData.Update"/> request has failed.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.UpdateSuccess.Equals(Akka.DistributedData.UpdateSuccess)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.UpdateSuccess.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.UpdateSuccess.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.UpdateSuccess.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IUpdateFailure">
            <summary>
            A common interface for <see cref="T:Akka.DistributedData.Update"/> responses that have ended with a failure.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IUpdateFailure.Cause">
            <summary>
            Returns a cause of the exception.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.UpdateTimeout">
            <summary>
            The direct replication of the <see cref="T:Akka.DistributedData.Update"/> could not be fulfill according to
            the given <see cref="T:Akka.DistributedData.IWriteConsistency"/> level and <see cref="P:Akka.DistributedData.IWriteConsistency.Timeout"/>.
            
            The <see cref="T:Akka.DistributedData.Update"/> was still performed locally and possibly replicated to some nodes.
            It will eventually be disseminated to other replicas, unless the local replica
            crashes before it has been able to communicate with other replicas.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.UpdateTimeout.Equals(Akka.DistributedData.UpdateTimeout)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.UpdateTimeout.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.UpdateTimeout.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.UpdateTimeout.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.ModifyFailure">
            <summary>
            If the `modify` function of the <see cref="T:Akka.DistributedData.Update"/> throws an exception the reply message
            will be this <see cref="T:Akka.DistributedData.ModifyFailure"/> message. The original exception is included as <see cref="P:Akka.DistributedData.ModifyFailure.Cause"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ModifyFailure.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.StoreFailure">
            <summary>
            The local store or direct replication of the <see cref="T:Akka.DistributedData.Update"/> could not be fulfill according to
            the given <see cref="T:Akka.DistributedData.IWriteConsistency"/> due to durable store errors. This is
            only used for entries that have been configured to be durable.
            
            The <see cref="T:Akka.DistributedData.Update"/> was still performed in memory locally and possibly replicated to some nodes,
            but it might not have been written to durable storage.
            It will eventually be disseminated to other replicas, unless the local replica
            crashes before it has been able to communicate with other replicas.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.StoreFailure.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.StoreFailure.Equals(Akka.DistributedData.StoreFailure)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.StoreFailure.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.StoreFailure.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.Delete">
            <summary>
            Send this message to the local <see cref="T:Akka.DistributedData.Replicator"/> to delete a data value for the
            given <see cref="P:Akka.DistributedData.Delete.Key"/>. The <see cref="T:Akka.DistributedData.Replicator"/> will reply with one of the <see cref="T:Akka.DistributedData.IDeleteResponse"/> messages.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Delete.Equals(Akka.DistributedData.Delete)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Delete.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Delete.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.Delete.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.IDeleteResponse">
            <summary>
            A response for a possible <see cref="T:Akka.DistributedData.Delete"/> request message. It can be one of 3 possible cases:
            <list type="bullet">
                <item>
                    <term><see cref="T:Akka.DistributedData.DeleteSuccess"/></term>
                    <description>Returned when data was deleted successfully.</description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.ReplicationDeleteFailure"/></term>
                    <description>Returned when delete operation ended with failure.</description>
                </item>
                <item>
                    <term><see cref="T:Akka.DistributedData.DataDeleted"/></term>
                    <description>Returned when an operation attempted to delete already deleted data.</description>
                </item>
            </list>
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IDeleteResponse.Key">
            <summary>
            Key, for which data was deleted.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IDeleteResponse.IsSuccessful">
            <summary>
            Returns true if value for provided <see cref="P:Akka.DistributedData.IDeleteResponse.Key"/> was either successfully deleted, or was deleted already.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.IDeleteResponse.AlreadyDeleted">
            <summary>
            Returns true if value for provided <see cref="P:Akka.DistributedData.IDeleteResponse.Key"/> was already deleted.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.DeleteSuccess.Equals(Akka.DistributedData.DeleteSuccess)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DeleteSuccess.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DeleteSuccess.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DeleteSuccess.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicationDeleteFailure.Equals(Akka.DistributedData.ReplicationDeleteFailure)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicationDeleteFailure.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicationDeleteFailure.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicationDeleteFailure.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DataDeleted.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DataDeleted.Equals(Akka.DistributedData.DataDeleted)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DataDeleted.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.DataDeleted.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.GetReplicaCount">
            <summary>
            Get current number of replicas, including the local replica.
            Will reply to sender with <see cref="T:Akka.DistributedData.ReplicaCount"/>.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.ReplicaCount">
            <summary>
            Current number of replicas. Reply to <see cref="T:Akka.DistributedData.GetReplicaCount"/>.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.ReplicaCount.Equals(Akka.DistributedData.ReplicaCount)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicaCount.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicaCount.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.ReplicaCount.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.FlushChanges">
            <summary>
            Notify subscribers of changes now, otherwise they will be notified periodically
            with the configured `notify-subscribers-interval`.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.FlushChanges.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.DistributedData.DataDeletedException">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.DistributedData.DataDeletedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.DistributedData.DataDeletedException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.DistributedData.ReplicatorSettings.Create(Akka.Actor.ActorSystem)">
            <summary>
            Create settings from the default configuration `akka.cluster.distributed-data`.
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.DistributedData.ReplicatorSettings.Create(Akka.Configuration.Config)">
            <summary>
            Create settings from a configuration with the same layout as
            the default configuration `akka.cluster.distributed-data`.
            </summary>
            <param name="config">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.IsDurable">
            <summary>
            Determines if a durable store has been configured and is used. If configuration has defined some 
            durable keys, this field must be true.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.Role">
            <summary>
            Replicas are running on members tagged with this role. All members are used if undefined.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.GossipInterval">
            <summary>
            How often the Replicator should send out gossip information.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.NotifySubscribersInterval">
            <summary>
            How often the subscribers will be notified of changes, if any.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.MaxDeltaElements">
            <summary>
            Maximum number of entries to transfer in one gossip message when synchronizing 
            the replicas.Next chunk will be transferred in next round of gossip.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.Dispatcher">
            <summary>
            Id of the dispatcher to use for Replicator actors. 
            If not specified the default dispatcher is used.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.PruningInterval">
            <summary>
            How often the Replicator checks for pruning of data associated with removed cluster nodes.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.MaxPruningDissemination">
            <summary>
            How long time it takes (worst case) to spread the data to all other replica nodes.
            This is used when initiating and completing the pruning process of data associated 
            with removed cluster nodes. The time measurement is stopped when any replica is 
            unreachable, so it should be configured to worst case in a healthy cluster.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.DurableKeys">
            <summary>
            Keys that are durable. Prefix matching is supported by using `*` at the end of a key.
            All entries can be made durable by including "*" in the `Set`.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.PruningMarkerTimeToLive">
            <summary>
            How long the tombstones of a removed node are kept on their CRDTs.
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.DurablePruningMarkerTimeToLive">
            <summary>
            
            </summary>
        </member>
        <member name="P:Akka.DistributedData.ReplicatorSettings.DurableStoreProps">
            <summary>
            Props for the durable store actor, when taken from actor class type name, it requires
            its constructor to take <see cref="T:Akka.Configuration.Config"/> as constructor parameter.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.ReplicatedDataMessagesReflection">
            <summary>Holder for reflection information generated from ReplicatedDataMessages.proto</summary>
        </member>
        <member name="P:Akka.DistributedData.Serialization.Proto.Msg.ReplicatedDataMessagesReflection.Descriptor">
            <summary>File descriptor for ReplicatedDataMessages.proto</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.TypeDescriptor.TypeFieldNumber">
            <summary>Field number for the "type" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.TypeDescriptor.TypeNameFieldNumber">
            <summary>Field number for the "TypeName" field.</summary>
        </member>
        <member name="P:Akka.DistributedData.Serialization.Proto.Msg.TypeDescriptor.TypeName">
            <summary>
            used when ValType.Other is selected  
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GSet.StringElementsFieldNumber">
            <summary>Field number for the "stringElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GSet.TypeInfoFieldNumber">
            <summary>Field number for the "typeInfo" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GSet.IntElementsFieldNumber">
            <summary>Field number for the "intElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GSet.LongElementsFieldNumber">
            <summary>Field number for the "longElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GSet.OtherElementsFieldNumber">
            <summary>Field number for the "otherElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GSet.ActorRefElementsFieldNumber">
            <summary>Field number for the "actorRefElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.VvectorFieldNumber">
            <summary>Field number for the "vvector" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.TypeInfoFieldNumber">
            <summary>Field number for the "typeInfo" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.DotsFieldNumber">
            <summary>Field number for the "dots" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.StringElementsFieldNumber">
            <summary>Field number for the "stringElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.IntElementsFieldNumber">
            <summary>Field number for the "intElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.LongElementsFieldNumber">
            <summary>Field number for the "longElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.OtherElementsFieldNumber">
            <summary>Field number for the "otherElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSet.ActorRefElementsFieldNumber">
            <summary>Field number for the "actorRefElements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSetDeltaGroup.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSetDeltaGroup.TypeInfoFieldNumber">
            <summary>Field number for the "typeInfo" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.ORSetDeltaGroup.Types">
            <summary>Container for nested types declared in the ORSetDeltaGroup message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSetDeltaGroup.Types.Entry.OperationFieldNumber">
            <summary>Field number for the "operation" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORSetDeltaGroup.Types.Entry.UnderlyingFieldNumber">
            <summary>Field number for the "underlying" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Flag.EnabledFieldNumber">
            <summary>Field number for the "enabled" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWRegister.TimestampFieldNumber">
            <summary>Field number for the "timestamp" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWRegister.NodeFieldNumber">
            <summary>Field number for the "node" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWRegister.StateFieldNumber">
            <summary>Field number for the "state" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWRegister.TypeInfoFieldNumber">
            <summary>Field number for the "typeInfo" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GCounter.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.GCounter.Types">
            <summary>Container for nested types declared in the GCounter message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GCounter.Types.Entry.NodeFieldNumber">
            <summary>Field number for the "node" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GCounter.Types.Entry.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounter.IncrementsFieldNumber">
            <summary>Field number for the "increments" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounter.DecrementsFieldNumber">
            <summary>Field number for the "decrements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.KeysFieldNumber">
            <summary>Field number for the "keys" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.ValueTypeInfoFieldNumber">
            <summary>Field number for the "valueTypeInfo" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.ORMap.Types">
            <summary>Container for nested types declared in the ORMap message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.Types.Entry.StringKeyFieldNumber">
            <summary>Field number for the "stringKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.Types.Entry.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.Types.Entry.IntKeyFieldNumber">
            <summary>Field number for the "intKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.Types.Entry.LongKeyFieldNumber">
            <summary>Field number for the "longKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMap.Types.Entry.OtherKeyFieldNumber">
            <summary>Field number for the "otherKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.KeyTypeInfoFieldNumber">
            <summary>Field number for the "keyTypeInfo" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.ValueTypeInfoFieldNumber">
            <summary>Field number for the "valueTypeInfo" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types">
            <summary>Container for nested types declared in the ORMapDeltaGroup message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.MapEntry.StringKeyFieldNumber">
            <summary>Field number for the "stringKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.MapEntry.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.MapEntry.IntKeyFieldNumber">
            <summary>Field number for the "intKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.MapEntry.LongKeyFieldNumber">
            <summary>Field number for the "longKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.MapEntry.OtherKeyFieldNumber">
            <summary>Field number for the "otherKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.Entry.OperationFieldNumber">
            <summary>Field number for the "operation" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.Entry.UnderlyingFieldNumber">
            <summary>Field number for the "underlying" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.Entry.ZeroTagFieldNumber">
            <summary>Field number for the "zeroTag" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMapDeltaGroup.Types.Entry.EntryDataFieldNumber">
            <summary>Field number for the "entryData" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMapDelta.DeltaFieldNumber">
            <summary>Field number for the "delta" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMapDelta.WithValueDeltasFieldNumber">
            <summary>Field number for the "withValueDeltas" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.KeysFieldNumber">
            <summary>Field number for the "keys" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.ValueTypeInfoFieldNumber">
            <summary>Field number for the "valueTypeInfo" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.Types">
            <summary>Container for nested types declared in the LWWMap message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.Types.Entry.StringKeyFieldNumber">
            <summary>Field number for the "stringKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.Types.Entry.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.Types.Entry.IntKeyFieldNumber">
            <summary>Field number for the "intKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.Types.Entry.LongKeyFieldNumber">
            <summary>Field number for the "longKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.LWWMap.Types.Entry.OtherKeyFieldNumber">
            <summary>Field number for the "otherKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.KeysFieldNumber">
            <summary>Field number for the "keys" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.Types">
            <summary>Container for nested types declared in the PNCounterMap message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.Types.Entry.StringKeyFieldNumber">
            <summary>Field number for the "stringKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.Types.Entry.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.Types.Entry.IntKeyFieldNumber">
            <summary>Field number for the "intKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.Types.Entry.LongKeyFieldNumber">
            <summary>Field number for the "longKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.PNCounterMap.Types.Entry.OtherKeyFieldNumber">
            <summary>Field number for the "otherKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.KeysFieldNumber">
            <summary>Field number for the "keys" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.WithValueDeltasFieldNumber">
            <summary>Field number for the "withValueDeltas" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.ValueTypeInfoFieldNumber">
            <summary>Field number for the "valueTypeInfo" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.Types">
            <summary>Container for nested types declared in the ORMultiMap message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.Types.Entry.StringKeyFieldNumber">
            <summary>Field number for the "stringKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.Types.Entry.ValueFieldNumber">
            <summary>Field number for the "value" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.Types.Entry.IntKeyFieldNumber">
            <summary>Field number for the "intKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.Types.Entry.LongKeyFieldNumber">
            <summary>Field number for the "longKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ORMultiMap.Types.Entry.OtherKeyFieldNumber">
            <summary>Field number for the "otherKey" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Key.KeyIdFieldNumber">
            <summary>Field number for the "keyId" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Key.KeyTypeFieldNumber">
            <summary>Field number for the "keyType" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Key.KeyTypeInfoFieldNumber">
            <summary>Field number for the "keyTypeInfo" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Key.ValueTypeInfoFieldNumber">
            <summary>Field number for the "valueTypeInfo" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.ReplicatorMessagesReflection">
            <summary>Holder for reflection information generated from replicatormessages.proto</summary>
        </member>
        <member name="P:Akka.DistributedData.Serialization.Proto.Msg.ReplicatorMessagesReflection.Descriptor">
            <summary>File descriptor for ReplicatorMessages.proto</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.ConsistencyFieldNumber">
            <summary>Field number for the "consistency" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.TimeoutFieldNumber">
            <summary>Field number for the "timeout" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.RequestFieldNumber">
            <summary>Field number for the "request" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.ConsistencyMinCapFieldNumber">
            <summary>Field number for the "consistencyMinCap" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.HasConsistencyAdditionalFieldNumber">
            <summary>Field number for the "hasConsistencyAdditional" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Get.ConsistencyAdditionalFieldNumber">
            <summary>Field number for the "consistencyAdditional" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GetSuccess.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GetSuccess.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GetSuccess.RequestFieldNumber">
            <summary>Field number for the "request" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.NotFound.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.NotFound.RequestFieldNumber">
            <summary>Field number for the "request" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GetFailure.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.GetFailure.RequestFieldNumber">
            <summary>Field number for the "request" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Subscribe.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Subscribe.RefFieldNumber">
            <summary>Field number for the "ref" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Unsubscribe.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Unsubscribe.RefFieldNumber">
            <summary>Field number for the "ref" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Changed.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Changed.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Write.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Write.EnvelopeFieldNumber">
            <summary>Field number for the "envelope" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Write.FromNodeFieldNumber">
            <summary>Field number for the "fromNode" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Read.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Read.FromNodeFieldNumber">
            <summary>Field number for the "fromNode" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.ReadResult.EnvelopeFieldNumber">
            <summary>Field number for the "envelope" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.PruningFieldNumber">
            <summary>Field number for the "pruning" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.DeltaVersionsFieldNumber">
            <summary>Field number for the "deltaVersions" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.Types">
            <summary>Container for nested types declared in the DataEnvelope message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.Types.PruningEntry.RemovedAddressFieldNumber">
            <summary>Field number for the "removedAddress" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.Types.PruningEntry.OwnerAddressFieldNumber">
            <summary>Field number for the "ownerAddress" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.Types.PruningEntry.PerformedFieldNumber">
            <summary>Field number for the "performed" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.Types.PruningEntry.SeenFieldNumber">
            <summary>Field number for the "seen" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DataEnvelope.Types.PruningEntry.ObsoleteTimeFieldNumber">
            <summary>Field number for the "obsoleteTime" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.ChunkFieldNumber">
            <summary>Field number for the "chunk" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.TotChunksFieldNumber">
            <summary>Field number for the "totChunks" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.ToSystemUidFieldNumber">
            <summary>Field number for the "toSystemUid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.FromSystemUidFieldNumber">
            <summary>Field number for the "fromSystemUid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.HasToSystemUidFieldNumber">
            <summary>Field number for the "hasToSystemUid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.HasFromSystemUidFieldNumber">
            <summary>Field number for the "hasFromSystemUid" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.Status.Types">
            <summary>Container for nested types declared in the Status message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.Types.Entry.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Status.Types.Entry.DigestFieldNumber">
            <summary>Field number for the "digest" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.SendBackFieldNumber">
            <summary>Field number for the "sendBack" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.ToSystemUidFieldNumber">
            <summary>Field number for the "toSystemUid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.FromSystemUidFieldNumber">
            <summary>Field number for the "fromSystemUid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.HasToSystemUidFieldNumber">
            <summary>Field number for the "hasToSystemUid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.HasFromSystemUidFieldNumber">
            <summary>Field number for the "hasFromSystemUid" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.Gossip.Types">
            <summary>Container for nested types declared in the Gossip message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.Types.Entry.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Gossip.Types.Entry.EnvelopeFieldNumber">
            <summary>Field number for the "envelope" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.FromNodeFieldNumber">
            <summary>Field number for the "fromNode" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.ReplyFieldNumber">
            <summary>Field number for the "reply" field.</summary>
        </member>
        <member name="P:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Reply">
            <summary>
            no reply if not set
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Types">
            <summary>Container for nested types declared in the DeltaPropagation message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Types.Entry.KeyFieldNumber">
            <summary>Field number for the "key" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Types.Entry.EnvelopeFieldNumber">
            <summary>Field number for the "envelope" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Types.Entry.FromSeqNrFieldNumber">
            <summary>Field number for the "fromSeqNr" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Types.Entry.ToSeqNrFieldNumber">
            <summary>Field number for the "toSeqNr" field.</summary>
        </member>
        <member name="P:Akka.DistributedData.Serialization.Proto.Msg.DeltaPropagation.Types.Entry.ToSeqNr">
            <summary>
            if not set then same as fromSequenceNr
            </summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.UniqueAddress.AddressFieldNumber">
            <summary>Field number for the "address" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.UniqueAddress.UidFieldNumber">
            <summary>Field number for the "uid" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Address.HostnameFieldNumber">
            <summary>Field number for the "hostname" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.Address.PortFieldNumber">
            <summary>Field number for the "port" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.VersionVector.EntriesFieldNumber">
            <summary>Field number for the "entries" field.</summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.Proto.Msg.VersionVector.Types">
            <summary>Container for nested types declared in the VersionVector message type.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.VersionVector.Types.Entry.NodeFieldNumber">
            <summary>Field number for the "node" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.VersionVector.Types.Entry.VersionFieldNumber">
            <summary>Field number for the "version" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.OtherMessage.EnclosedMessageFieldNumber">
            <summary>Field number for the "enclosedMessage" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.OtherMessage.SerializerIdFieldNumber">
            <summary>Field number for the "serializerId" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.OtherMessage.MessageManifestFieldNumber">
            <summary>Field number for the "messageManifest" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.StringGSet.ElementsFieldNumber">
            <summary>Field number for the "elements" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DurableDataEnvelope.DataFieldNumber">
            <summary>Field number for the "data" field.</summary>
        </member>
        <member name="F:Akka.DistributedData.Serialization.Proto.Msg.DurableDataEnvelope.PruningFieldNumber">
            <summary>Field number for the "pruning" field.</summary>
        </member>
        <member name="M:Akka.DistributedData.Serialization.ReplicatedDataSerializer.ORSetUnknownToProto``1(Akka.DistributedData.IORSet)">
            <summary>
            Called when we're serializing none of the standard object types with ORSet
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Serialization.ReplicatorMessageSerializer.SmallCache`2.Add(`0,`1)">
            <summary>
            Add value under specified key. Overrides existing entry.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Serialization.ReplicatorMessageSerializer.SmallCache`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Add an entry to the cache. Overrides existing entry.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.Serialization.ReplicatorMessageSerializer.SmallCache`2.Evict">
            <summary>
            Remove all elements if the if cache has not been used within <see cref="F:Akka.DistributedData.Serialization.ReplicatorMessageSerializer.SmallCache`2._ttl"/>.
            </summary>
        </member>
        <member name="T:Akka.DistributedData.Serialization.SerializationSupport">
             <summary>
             INTERNAL API.
            
             Used to support the DData serializers.
             </summary>
        </member>
        <member name="T:Akka.DistributedData.VersionVector">
            <summary>
            Representation of a Vector-based clock (counting clock), inspired by Lamport logical clocks.
            Based on code from <see cref="T:Akka.Cluster.VectorClock"/>.
            
            This class is immutable, i.e. "modifying" methods return a new instance.
            </summary>
        </member>
        <member name="F:Akka.DistributedData.VersionVector.EndMarker">
            <summary>
            Marker to signal that we have reached the end of a version vector.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.Increment(Akka.Cluster.UniqueAddress)">
            <summary>
            Increment the version for the node passed as argument. Returns a new VersionVector.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.Merge(Akka.DistributedData.VersionVector)">
            <summary>
            Merges this VersionVector with another VersionVector. E.g. merges its versioned history.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.Equals(Akka.DistributedData.VersionVector)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.IsSame(Akka.DistributedData.VersionVector)">
            <summary>
            Returns true if this VersionVector has the same history
            as the <paramref name="y"/> VersionVector else false.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.op_Inequality(Akka.DistributedData.VersionVector,Akka.DistributedData.VersionVector)">
            <summary>
            Returns true if <paramref name="x"/> VersionVector has other 
            history than the <paramref name="y"/> VersionVector else false.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.op_GreaterThan(Akka.DistributedData.VersionVector,Akka.DistributedData.VersionVector)">
            <summary>
            Returns true if <paramref name="x"/> is after <paramref name="y"/> else false.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.op_LessThan(Akka.DistributedData.VersionVector,Akka.DistributedData.VersionVector)">
            <summary>
            Returns true if <paramref name="x"/> is before <paramref name="y"/> else false.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.Compare(Akka.DistributedData.VersionVector)">
            <summary>
            Compare two version vectors. The outcome will be one of the following:
            
            <para>Version 1 is SAME (==)       as Version 2 iff for all i c1(i) == c2(i)</para>
            <para>Version 1 is BEFORE (&lt;)      Version 2 iff for all i c1(i) &lt;= c2(i) and there exist a j such that c1(j) &lt; c2(j)</para>
            <para>Version 1 is AFTER (&gt;)       Version 2 iff for all i c1(i) &gt;= c2(i) and there exist a j such that c1(j) &gt; c2(j)</para>
            <para>Version 1 is CONCURRENT to Version 2 otherwise</para>
            </summary>
        </member>
        <member name="M:Akka.DistributedData.VersionVector.CompareOnlyTo(Akka.DistributedData.VersionVector,Akka.DistributedData.VersionVector.Ordering)">
            <summary>
            Version vector comparison according to the semantics described by compareTo, with the ability to bail
            out early if the we can't reach the Ordering that we are looking for.
            
            The ordering always starts with <see cref="F:Akka.DistributedData.VersionVector.Ordering.Same"/> and can then go to Same, Before or After
            If we're on <see cref="F:Akka.DistributedData.VersionVector.Ordering.After"/> we can only go to After or Concurrent
            If we're on <see cref="F:Akka.DistributedData.VersionVector.Ordering.Before"/> we can only go to Before or Concurrent
            If we go to <see cref="F:Akka.DistributedData.VersionVector.Ordering.Concurrent"/> we exit the loop immediately
            
            If you send in the ordering <see cref="F:Akka.DistributedData.VersionVector.Ordering.FullOrder"/>, you will get a full comparison.
            </summary>
        </member>
        <member name="M:Akka.DistributedData.SingleVersionVector.Enumerator.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.MultiVersionVector.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.MultiVersionVector.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.WriteLocal.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.WriteTo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.WriteMajority.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.DistributedData.WriteAll.Equals(System.Object)">
            <inheritdoc/>
        </member>
    </members>
</doc>
